{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Core Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Core utilities to complement Python's standard library.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>For information on how to use this library, please refer to the documentation.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Core Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>core<ul> <li>asyncio</li> <li>datetime</li> <li>logging</li> <li>math</li> <li>typing</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/core/","title":"Index","text":""},{"location":"reference/frequenz/core/#frequenz.core","title":"frequenz.core","text":"<p>Core utilities to complement Python's standard library.</p>"},{"location":"reference/frequenz/core/datetime/","title":"datetime","text":""},{"location":"reference/frequenz/core/datetime/#frequenz.core.datetime","title":"frequenz.core.datetime","text":"<p>Timeseries basic types.</p>"},{"location":"reference/frequenz/core/datetime/#frequenz.core.datetime-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/datetime/#frequenz.core.datetime.UNIX_EPOCH","title":"frequenz.core.datetime.UNIX_EPOCH  <code>module-attribute</code>","text":"<pre><code>UNIX_EPOCH = fromtimestamp(0.0, tz=utc)\n</code></pre> <p>The UNIX epoch (in UTC).</p>"},{"location":"reference/frequenz/core/logging/","title":"logging","text":""},{"location":"reference/frequenz/core/logging/#frequenz.core.logging","title":"frequenz.core.logging","text":"<p>Logging tools.</p>"},{"location":"reference/frequenz/core/logging/#frequenz.core.logging-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/logging/#frequenz.core.logging.get_public_logger","title":"frequenz.core.logging.get_public_logger","text":"<pre><code>get_public_logger(module_name: str) -&gt; Logger\n</code></pre> <p>Get a logger for the public module containing the given module name.</p> <ul> <li>Modules are considered private if they start with <code>_</code>.</li> <li>All modules inside a private module are also considered private, even if they   don't start with <code>_</code>.</li> <li>If there is no leading public part, the root logger is returned.</li> </ul> Example <p>Here are a few examples of how this function will resolve module names:</p> <ul> <li><code>some.pub</code> -&gt; <code>some.pub</code></li> <li><code>some.pub._some._priv</code> -&gt; <code>some.pub</code></li> <li><code>some.pub._some._priv.public</code> -&gt; <code>some.pub</code></li> <li><code>some.pub._some._priv.public._private</code> -&gt; <code>some.pub</code></li> <li><code>_priv</code> -&gt; <code>root</code></li> </ul> PARAMETER DESCRIPTION <code>module_name</code> <p>The fully qualified name of the module to get the logger for (normally the <code>__name__</code> built-in variable).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Logger</code> <p>The logger for the public module containing the given module name.</p> Source code in <code>frequenz/core/logging.py</code> <pre><code>def get_public_logger(module_name: str) -&gt; logging.Logger:\n    \"\"\"Get a logger for the public module containing the given module name.\n\n    * Modules are considered private if they start with `_`.\n    * All modules inside a private module are also considered private, even if they\n      don't start with `_`.\n    * If there is no leading public part, the root logger is returned.\n\n    Example:\n        Here are a few examples of how this function will resolve module names:\n\n        * `some.pub` -&gt; `some.pub`\n        * `some.pub._some._priv` -&gt; `some.pub`\n        * `some.pub._some._priv.public` -&gt; `some.pub`\n        * `some.pub._some._priv.public._private` -&gt; `some.pub`\n        * `_priv` -&gt; `root`\n\n    Args:\n        module_name: The fully qualified name of the module to get the logger for\n            (normally the `__name__` built-in variable).\n\n    Returns:\n        The logger for the public module containing the given module name.\n    \"\"\"\n    public_parts: list[str] = []\n    for part in module_name.split(\".\"):\n        if part.startswith(\"_\"):\n            break\n        public_parts.append(part)\n    return logging.getLogger(\".\".join(public_parts))\n</code></pre>"},{"location":"reference/frequenz/core/math/","title":"math","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math","title":"frequenz.core.math","text":"<p>Math tools.</p>"},{"location":"reference/frequenz/core/math/#frequenz.core.math-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.LessThanComparableOrNoneT","title":"frequenz.core.math.LessThanComparableOrNoneT  <code>module-attribute</code>","text":"<pre><code>LessThanComparableOrNoneT = TypeVar(\n    \"LessThanComparableOrNoneT\",\n    bound=LessThanComparable | None,\n)\n</code></pre> <p>Type variable for a value that a <code>LessThanComparable</code> or <code>None</code>.</p>"},{"location":"reference/frequenz/core/math/#frequenz.core.math-classes","title":"Classes","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval","title":"frequenz.core.math.Interval  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[LessThanComparableOrNoneT]</code></p> <p>An interval to test if a value is within its limits.</p> <p>The <code>start</code> and <code>end</code> are inclusive, meaning that the <code>start</code> and <code>end</code> limites are included in the range when checking if a value is contained by the interval.</p> <p>If the <code>start</code> or <code>end</code> is <code>None</code>, it means that the interval is unbounded in that direction.</p> <p>If <code>start</code> is bigger than <code>end</code>, a <code>ValueError</code> is raised.</p> <p>The type stored in the interval must be comparable, meaning that it must implement the <code>__lt__</code> method to be able to compare values.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass Interval(Generic[LessThanComparableOrNoneT]):\n    \"\"\"An interval to test if a value is within its limits.\n\n    The `start` and `end` are inclusive, meaning that the `start` and `end` limites are\n    included in the range when checking if a value is contained by the interval.\n\n    If the `start` or `end` is `None`, it means that the interval is unbounded in that\n    direction.\n\n    If `start` is bigger than `end`, a `ValueError` is raised.\n\n    The type stored in the interval must be comparable, meaning that it must implement\n    the `__lt__` method to be able to compare values.\n    \"\"\"\n\n    start: LessThanComparableOrNoneT\n    \"\"\"The start of the interval.\"\"\"\n\n    end: LessThanComparableOrNoneT\n    \"\"\"The end of the interval.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Check if the start is less than or equal to the end.\"\"\"\n        if self.start is None or self.end is None:\n            return\n        start = cast(LessThanComparable, self.start)\n        end = cast(LessThanComparable, self.end)\n        if start &gt; end:\n            raise ValueError(\n                f\"The start ({self.start}) can't be bigger than end ({self.end})\"\n            )\n\n    def __contains__(self, item: LessThanComparableOrNoneT) -&gt; bool:\n        \"\"\"\n        Check if the value is within the range of the container.\n\n        Args:\n            item: The value to check.\n\n        Returns:\n            bool: True if value is within the range, otherwise False.\n        \"\"\"\n        if item is None:\n            return False\n        casted_item = cast(LessThanComparable, item)\n\n        if self.start is None and self.end is None:\n            return True\n        if self.start is None:\n            start = cast(LessThanComparable, self.end)\n            return not casted_item &gt; start\n        if self.end is None:\n            return not self.start &gt; item\n        # mypy seems to get confused here, not being able to narrow start and end to\n        # just LessThanComparable, complaining with:\n        #   error: Unsupported left operand type for &lt;= (some union)\n        # But we know if they are not None, they should be LessThanComparable, and\n        # actually mypy is being able to figure it out in the lines above, just not in\n        # this one, so it should be safe to cast.\n        return not (\n            casted_item &lt; cast(LessThanComparable, self.start)\n            or casted_item &gt; cast(LessThanComparable, self.end)\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\"\"\"\n        return f\"Interval({self.start!r}, {self.end!r})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\"\"\"\n        start = \"\u221e\" if self.start is None else str(self.start)\n        end = \"\u221e\" if self.end is None else str(self.end)\n        return f\"[{start}, {end}]\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: LessThanComparableOrNoneT\n</code></pre> <p>The end of the interval.</p>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: LessThanComparableOrNoneT\n</code></pre> <p>The start of the interval.</p>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: LessThanComparableOrNoneT) -&gt; bool\n</code></pre> <p>Check if the value is within the range of the container.</p> PARAMETER DESCRIPTION <code>item</code> <p>The value to check.</p> <p> TYPE: <code>LessThanComparableOrNoneT</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if value is within the range, otherwise False.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __contains__(self, item: LessThanComparableOrNoneT) -&gt; bool:\n    \"\"\"\n    Check if the value is within the range of the container.\n\n    Args:\n        item: The value to check.\n\n    Returns:\n        bool: True if value is within the range, otherwise False.\n    \"\"\"\n    if item is None:\n        return False\n    casted_item = cast(LessThanComparable, item)\n\n    if self.start is None and self.end is None:\n        return True\n    if self.start is None:\n        start = cast(LessThanComparable, self.end)\n        return not casted_item &gt; start\n    if self.end is None:\n        return not self.start &gt; item\n    # mypy seems to get confused here, not being able to narrow start and end to\n    # just LessThanComparable, complaining with:\n    #   error: Unsupported left operand type for &lt;= (some union)\n    # But we know if they are not None, they should be LessThanComparable, and\n    # actually mypy is being able to figure it out in the lines above, just not in\n    # this one, so it should be safe to cast.\n    return not (\n        casted_item &lt; cast(LessThanComparable, self.start)\n        or casted_item &gt; cast(LessThanComparable, self.end)\n    )\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Check if the start is less than or equal to the end.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Check if the start is less than or equal to the end.\"\"\"\n    if self.start is None or self.end is None:\n        return\n    start = cast(LessThanComparable, self.start)\n    end = cast(LessThanComparable, self.end)\n    if start &gt; end:\n        raise ValueError(\n            f\"The start ({self.start}) can't be bigger than end ({self.end})\"\n        )\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\"\"\"\n    return f\"Interval({self.start!r}, {self.end!r})\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\"\"\"\n    start = \"\u221e\" if self.start is None else str(self.start)\n    end = \"\u221e\" if self.end is None else str(self.end)\n    return f\"[{start}, {end}]\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.LessThanComparable","title":"frequenz.core.math.LessThanComparable","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol that requires the <code>__lt__</code> method to compare values.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>class LessThanComparable(Protocol):\n    \"\"\"A protocol that requires the `__lt__` method to compare values.\"\"\"\n\n    def __lt__(self, other: Self, /) -&gt; bool:\n        \"\"\"Return whether self is less than other.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.LessThanComparable-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.LessThanComparable.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether self is less than other.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __lt__(self, other: Self, /) -&gt; bool:\n    \"\"\"Return whether self is less than other.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.is_close_to_zero","title":"frequenz.core.math.is_close_to_zero","text":"<pre><code>is_close_to_zero(\n    value: float, abs_tol: float = 1e-09\n) -&gt; bool\n</code></pre> <p>Check if a floating point value is close to zero.</p> <p>A value of 1e-9 is a commonly used absolute tolerance to balance precision and robustness for floating-point numbers comparisons close to zero. Note that this is also the default value for the relative tolerance. For more technical details, see https://peps.python.org/pep-0485/#behavior-near-zero</p> PARAMETER DESCRIPTION <code>value</code> <p>The floating point value to compare to.</p> <p> TYPE: <code>float</code> </p> <code>abs_tol</code> <p>The minimum absolute tolerance. Defaults to 1e-9.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the floating point value is close to zero.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def is_close_to_zero(value: float, abs_tol: float = 1e-9) -&gt; bool:\n    \"\"\"Check if a floating point value is close to zero.\n\n    A value of 1e-9 is a commonly used absolute tolerance to balance precision\n    and robustness for floating-point numbers comparisons close to zero. Note\n    that this is also the default value for the relative tolerance.\n    For more technical details, see https://peps.python.org/pep-0485/#behavior-near-zero\n\n    Args:\n        value: The floating point value to compare to.\n        abs_tol: The minimum absolute tolerance. Defaults to 1e-9.\n\n    Returns:\n        Whether the floating point value is close to zero.\n    \"\"\"\n    zero: float = 0.0\n    return math.isclose(a=value, b=zero, abs_tol=abs_tol)\n</code></pre>"},{"location":"reference/frequenz/core/typing/","title":"typing","text":""},{"location":"reference/frequenz/core/typing/#frequenz.core.typing","title":"frequenz.core.typing","text":"<p>Type hints and utility functions for type checking and types.</p> <p>For now this module only provides a decorator to disable the <code>__init__</code> constructor of a class, to force the use of a factory method to create instances. See disable_init for more information.</p>"},{"location":"reference/frequenz/core/typing/#frequenz.core.typing-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/typing/#frequenz.core.typing.TypeT","title":"frequenz.core.typing.TypeT  <code>module-attribute</code>","text":"<pre><code>TypeT = TypeVar('TypeT', bound=type)\n</code></pre> <p>A type variable that is bound to a type.</p>"},{"location":"reference/frequenz/core/typing/#frequenz.core.typing-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/typing/#frequenz.core.typing.disable_init","title":"frequenz.core.typing.disable_init","text":"<pre><code>disable_init(\n    cls: TypeT | None = None,\n    *,\n    error: Exception | None = None\n) -&gt; TypeT | Callable[[TypeT], TypeT]\n</code></pre> <p>Disable the <code>__init__</code> constructor of a class.</p> <p>This decorator can be used to disable the <code>__init__</code> constructor of a class. It is intended to be used with classes that don't provide a default constructor and require the use of a factory method to create instances.</p> <p>When marking a class with this decorator, the class cannot be even declared with a <code>__init__</code> method, as it will raise a <code>TypeError</code> when the class is created, as soon as the class is parsed by the Python interpreter. It will also raise a <code>TypeError</code> when the <code>__init__</code> method is called.</p> <p>To create an instance you must provide a factory method, using <code>__new__</code>.</p> Warning <p>This decorator will use a custom metaclass to disable the <code>__init__</code> constructor of the class, so if your class already uses a custom metaclass, you should be aware of potential conflicts.</p> Basic example defining a class with a factory method <p>To be able to type hint the class correctly, you can declare the instance attributes in the class body, and then use a factory method to create instances.</p> <pre><code>from typing import Self\n\n@disable_init\nclass MyClass:\n    value: int\n\n    @classmethod\n    def new(cls, value: int = 1) -&gt; Self:\n        self = cls.__new__(cls)\n        self.value = value\n        return self\n\ninstance = MyClass.new()\n\n# Calling the default constructor (__init__) will raise a TypeError\ntry:\n    instance = MyClass()\nexcept TypeError as e:\n    print(e)\n</code></pre> Class wrongly providing an <code>__init__</code> constructor <pre><code>try:\n    @disable_init\n    class MyClass:\n        def __init__(self) -&gt; None:\n            pass\nexcept TypeError as e:\n    assert isinstance(e, TypeError)\n    print(e)\n</code></pre> Using a custom error message when the default constructor is called <pre><code>from typing import Self\n\nclass NoInitError(TypeError):\n    def __init__(self) -&gt; None:\n        super().__init__(\"Please create instances of MyClass using MyClass.new()\")\n\n@disable_init(error=NoInitError())\nclass MyClass:\n    @classmethod\n    def new(cls) -&gt; Self:\n        return cls.__new__(cls)\n\ntry:\n    instance = MyClass()\nexcept NoInitError as e:\n    assert str(e) == \"Please create instances of MyClass using MyClass.new()\"\n    print(e)\n</code></pre> PARAMETER DESCRIPTION <code>cls</code> <p>The class to be decorated.</p> <p> TYPE: <code>TypeT | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>The error to raise if init is called, if <code>None</code> a default TypeError will be raised.</p> <p> TYPE: <code>Exception | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>TypeT | Callable[[TypeT], TypeT]</code> <p>A decorator that disables the <code>__init__</code> constructor of <code>cls</code>.</p> Source code in <code>frequenz/core/typing.py</code> <pre><code>def disable_init(\n    cls: TypeT | None = None,\n    *,\n    error: Exception | None = None,\n) -&gt; TypeT | Callable[[TypeT], TypeT]:\n    \"\"\"Disable the `__init__` constructor of a class.\n\n    This decorator can be used to disable the `__init__` constructor of a class. It is\n    intended to be used with classes that don't provide a default constructor and\n    require the use of a factory method to create instances.\n\n    When marking a class with this decorator, the class cannot be even declared with a\n    `__init__` method, as it will raise a `TypeError` when the class is created, as soon\n    as the class is parsed by the Python interpreter. It will also raise a `TypeError`\n    when the `__init__` method is called.\n\n    To create an instance you must provide a factory method, using `__new__`.\n\n    Warning:\n        This decorator will use a custom metaclass to disable the `__init__` constructor\n        of the class, so if your class already uses a custom metaclass, you should be\n        aware of potential conflicts.\n\n    Example: Basic example defining a class with a factory method\n        To be able to type hint the class correctly, you can declare the instance\n        attributes in the class body, and then use a factory method to create instances.\n\n        ```python\n        from typing import Self\n\n        @disable_init\n        class MyClass:\n            value: int\n\n            @classmethod\n            def new(cls, value: int = 1) -&gt; Self:\n                self = cls.__new__(cls)\n                self.value = value\n                return self\n\n        instance = MyClass.new()\n\n        # Calling the default constructor (__init__) will raise a TypeError\n        try:\n            instance = MyClass()\n        except TypeError as e:\n            print(e)\n        ```\n\n    Example: Class wrongly providing an `__init__` constructor\n        ```python\n        try:\n            @disable_init\n            class MyClass:\n                def __init__(self) -&gt; None:\n                    pass\n        except TypeError as e:\n            assert isinstance(e, TypeError)\n            print(e)\n        ```\n\n    Example: Using a custom error message when the default constructor is called\n        ```python\n        from typing import Self\n\n        class NoInitError(TypeError):\n            def __init__(self) -&gt; None:\n                super().__init__(\"Please create instances of MyClass using MyClass.new()\")\n\n        @disable_init(error=NoInitError())\n        class MyClass:\n            @classmethod\n            def new(cls) -&gt; Self:\n                return cls.__new__(cls)\n\n        try:\n            instance = MyClass()\n        except NoInitError as e:\n            assert str(e) == \"Please create instances of MyClass using MyClass.new()\"\n            print(e)\n        ```\n\n    Args:\n        cls: The class to be decorated.\n        error: The error to raise if __init__ is called, if `None` a default\n            [TypeError][] will be raised.\n\n    Returns:\n        A decorator that disables the `__init__` constructor of `cls`.\n    \"\"\"\n\n    def decorator(inner_cls: TypeT) -&gt; TypeT:\n        return cast(\n            TypeT,\n            _NoInitConstructibleMeta(\n                inner_cls.__name__,\n                inner_cls.__bases__,\n                dict(inner_cls.__dict__),\n                no_init_constructible_error=error,\n            ),\n        )\n\n    if cls is None:\n        return decorator\n    return decorator(cls)\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/","title":"asyncio","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio","title":"frequenz.core.asyncio","text":"<p>General purpose async tools.</p> <p>This module provides general purpose async tools that can be used to simplify the development of asyncio-based applications.</p> <p>The module provides the following classes and functions:</p> <ul> <li>cancel_and_await: A function that cancels a   task and waits for it to finish, handling <code>CancelledError</code> exceptions.</li> <li>PersistentTaskGroup: An alternative to   <code>asyncio.TaskGroup</code> to manage tasks that run until explicitly stopped.</li> <li>Service: An interface for services running in the   background.</li> <li>ServiceBase: A base class for implementing   services running in the background.</li> <li>TaskCreator: A protocol for creating tasks.</li> </ul>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.TaskReturnT","title":"frequenz.core.asyncio.TaskReturnT  <code>module-attribute</code>","text":"<pre><code>TaskReturnT = TypeVar('TaskReturnT')\n</code></pre> <p>The type of the return value of a task.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio-classes","title":"Classes","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup","title":"frequenz.core.asyncio.PersistentTaskGroup","text":"<p>A group of tasks that should run until explicitly stopped.</p> <p><code>asyncio.TaskGroup</code> is a very convenient construct when using parallelization for doing calculations for example, where the results for all the tasks need to be merged together to produce a final result. In this case if one of the tasks fails, it makes sense to cancel the others and abort as soon as possible, as any further calculations would be thrown away.</p> <p>This class is intended to help managing a group of tasks that should persist even if other tasks in the group fail, usually by either only discarding the failed task or by restarting it somehow.</p> <p>This class is also typically used as a context manager, but in this case when the context manager is exited, the tasks are not only awaited, they are first cancelled, so all the background tasks are stopped. If any task was ended due to an unhandled exception, the exception will be re-raised when the context manager exits as <code>BaseExceptionGroup</code>.</p> <p>As with <code>asyncio.TaskGroup</code>, the tasks should be created using the <code>create_task()</code> method.</p> <p>To monitor the subtasks and handle exceptions or early termination, a <code>as_completed()</code> method is provided, similar to <code>asyncio.as_completed</code> but not quite the same. Using this method is the only way to acknowledge tasks failures, so they are not raised when the service is <code>await</code>ed or when the context manager is exited.</p> Example <p>This program will run forever, printing the current time now and then and restarting the failing task each time it crashes.</p> <pre><code>import asyncio\nimport datetime\n\nasync def print_every(*, seconds: float) -&gt; None:\n    while True:\n        await asyncio.sleep(seconds)\n        print(datetime.datetime.now())\n\nasync def fail_after(*, seconds: float) -&gt; None:\n    await asyncio.sleep(seconds)\n    raise ValueError(\"I failed\")\n\nasync def main() -&gt; None:\n\n    async with PersistentTaskGroup() as group:\n        group.create_task(print_every(seconds=1), name=\"print_1\")\n        group.create_task(print_every(seconds=11), name=\"print_11\")\n        failing = group.create_task(fail_after(seconds=5), name=f\"fail_5\")\n\n        async for task in group.as_completed():\n            assert task.done()  # For demonstration purposes only\n            try:\n                task.result()\n            except ValueError as error:\n                if failing == task:\n                    failing = group.create_task(fail_after(seconds=5), name=f\"fail_5\")\n                else:\n                    raise\n\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>class PersistentTaskGroup:\n    \"\"\"A group of tasks that should run until explicitly stopped.\n\n    [`asyncio.TaskGroup`][] is a very convenient construct when using parallelization\n    for doing calculations for example, where the results for all the tasks need to be\n    merged together to produce a final result. In this case if one of the tasks fails,\n    it makes sense to cancel the others and abort as soon as possible, as any further\n    calculations would be thrown away.\n\n    This class is intended to help managing a group of tasks that should persist even if\n    other tasks in the group fail, usually by either only discarding the failed task or\n    by restarting it somehow.\n\n    This class is also typically used as a context manager, but in this case when the\n    context manager is exited, the tasks are not only awaited, they are first cancelled,\n    so all the background tasks are stopped. If any task was ended due to an unhandled\n    exception, the exception will be re-raised when the context manager exits as\n    [`BaseExceptionGroup`][].\n\n    As with [`asyncio.TaskGroup`][], the tasks should be created using the\n    [`create_task()`][frequenz.core.asyncio.PersistentTaskGroup.create_task] method.\n\n    To monitor the subtasks and handle exceptions or early termination,\n    a [`as_completed()`][frequenz.core.asyncio.PersistentTaskGroup.as_completed] method\n    is provided, similar to [`asyncio.as_completed`][] but not quite the same. Using\n    this method is the only way to acknowledge tasks failures, so they are not raised\n    when the service is `await`ed or when the context manager is exited.\n\n    Example:\n        This program will run forever, printing the current time now and then and\n        restarting the failing task each time it crashes.\n\n        ```python\n        import asyncio\n        import datetime\n\n        async def print_every(*, seconds: float) -&gt; None:\n            while True:\n                await asyncio.sleep(seconds)\n                print(datetime.datetime.now())\n\n        async def fail_after(*, seconds: float) -&gt; None:\n            await asyncio.sleep(seconds)\n            raise ValueError(\"I failed\")\n\n        async def main() -&gt; None:\n\n            async with PersistentTaskGroup() as group:\n                group.create_task(print_every(seconds=1), name=\"print_1\")\n                group.create_task(print_every(seconds=11), name=\"print_11\")\n                failing = group.create_task(fail_after(seconds=5), name=f\"fail_5\")\n\n                async for task in group.as_completed():\n                    assert task.done()  # For demonstration purposes only\n                    try:\n                        task.result()\n                    except ValueError as error:\n                        if failing == task:\n                            failing = group.create_task(fail_after(seconds=5), name=f\"fail_5\")\n                        else:\n                            raise\n\n        asyncio.run(main())\n        ```\n    \"\"\"\n\n    def __init__(\n        self, *, unique_id: str | None = None, task_creator: TaskCreator = asyncio\n    ) -&gt; None:\n        \"\"\"Initialize this instance.\n\n        Args:\n            unique_id: The string to uniquely identify this instance. If `None`,\n                a string based on `hex(id(self))` will be used. This is used in\n                `__repr__` and `__str__` methods, mainly for debugging purposes, to\n                identify a particular instance of a persistent task group.\n            task_creator: The object that will be used to create tasks. Usually one of:\n                the [`asyncio`]() module, an [`asyncio.AbstractEventLoop`]() or\n                an [`asyncio.TaskGroup`]().\n        \"\"\"\n        # [2:] is used to remove the '0x' prefix from the hex representation of the id,\n        # as it doesn't add any uniqueness to the string.\n        self._unique_id: str = hex(id(self))[2:] if unique_id is None else unique_id\n        \"\"\"The unique ID of this instance.\"\"\"\n\n        self._task_creator: TaskCreator = task_creator\n        \"\"\"The object that will be used to create tasks.\"\"\"\n\n        self._running: set[asyncio.Task[Any]] = set()\n        \"\"\"The set of tasks that are still running.\n\n        Tasks are removed from this set automatically when they finish using the\n        Task.add_done_callback method.\n        \"\"\"\n\n        self._waiting_ack: set[asyncio.Task[Any]] = set()\n        \"\"\"The set of tasks that have finished but waiting for the user's ACK.\n\n        Tasks are added to this set automatically when they finish using the\n        Task.add_done_callback method.\n        \"\"\"\n\n    @property\n    def unique_id(self) -&gt; str:\n        \"\"\"The unique ID of this instance.\"\"\"\n        return self._unique_id\n\n    @property\n    def tasks(self) -&gt; Set[asyncio.Task[Any]]:\n        \"\"\"The set of tasks managed by this group.\n\n        Users typically should not modify the tasks in the returned set and only use\n        them for informational purposes.\n\n        Both running tasks and tasks pending for acknowledgment are included in the\n        returned set.\n\n        Danger:\n            Changing the returned tasks may lead to unexpected behavior, don't do it\n            unless the class explicitly documents it is safe to do so.\n        \"\"\"\n        return self._running | self._waiting_ack\n\n    @property\n    def task_creator(self) -&gt; TaskCreator:\n        \"\"\"The object that will be used to create tasks.\"\"\"\n        return self._task_creator\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Whether this task group is running.\n\n        A task group is considered running when at least one task is running.\n        \"\"\"\n        return bool(self._running)\n\n    def create_task(\n        self,\n        coro: Coroutine[Any, Any, TaskReturnT],\n        *,\n        name: str | None = None,\n        context: contextvars.Context | None = None,\n        log_exception: bool = True,\n    ) -&gt; asyncio.Task[TaskReturnT]:\n        \"\"\"Start a managed task.\n\n        A reference to the task will be held by the task group, so there is no need to\n        save the task object.\n\n        Tasks can be retrieved via the\n        [`tasks`][frequenz.core.asyncio.PersistentTaskGroup.tasks] property.\n\n        Managed tasks always have a `name` including information about the task group\n        itself. If you need to retrieve the final name of the task you can always do so\n        by calling [`.get_name()`][asyncio.Task.get_name] on the returned task.\n\n        Tasks created this way will also be automatically cancelled when calling\n        [`cancel()`][frequenz.core.asyncio.ServiceBase.cancel] or\n        [`stop()`][frequenz.core.asyncio.ServiceBase.stop], or when the service is used\n        as a async context manager.\n\n        To inform that a finished task was properly handled, the method\n        [`as_completed()`][frequenz.core.asyncio.PersistentTaskGroup.as_completed]\n        should be used.\n\n        Args:\n            coro: The coroutine to be managed.\n            name: The name of the task. Names will always have the form\n                `f\"{self}:{name}\"`. If `None` or empty, the default name will be\n                `hex(id(coro))[2:]`. If you need the final name of the task, it can\n                always be retrieved\n            context: The context to be used for the task.\n            log_exception: Whether to log exceptions raised by the task.\n\n        Returns:\n            The new task.\n        \"\"\"\n        if not name:\n            name = hex(id(coro))[2:]\n        task = self._task_creator.create_task(\n            coro, name=f\"{self}:{name}\", context=context\n        )\n        self._running.add(task)\n        task.add_done_callback(self._running.discard)\n        task.add_done_callback(self._waiting_ack.add)\n\n        if log_exception:\n\n            def _log_exception(task: asyncio.Task[TaskReturnT]) -&gt; None:\n                try:\n                    task.result()\n                except asyncio.CancelledError:\n                    pass\n                except BaseException:  # pylint: disable=broad-except\n                    _logger.exception(\n                        \"Task %s raised an unhandled exception\", task.get_name()\n                    )\n\n            task.add_done_callback(_log_exception)\n        return task\n\n    def cancel(self, msg: str | None = None) -&gt; None:\n        \"\"\"Cancel all running tasks spawned by this group.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        for task in self._running:\n            task.cancel(msg)\n\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this task group.\n\n        This method cancels all running tasks spawned by this group and waits for them\n        to finish.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this group raised an\n                exception.\n        \"\"\"\n        self.cancel(msg)\n        try:\n            await self\n        except BaseExceptionGroup as exc_group:\n            # We want to ignore CancelledError here as we explicitly cancelled all the\n            # tasks.\n            _, rest = exc_group.split(asyncio.CancelledError)\n            if rest is not None:\n                # We are filtering out from an exception group, we really don't want to\n                # add the exceptions we just filtered by adding a from clause here.\n                raise rest  # pylint: disable=raise-missing-from\n\n    async def as_completed(\n        self, *, timeout: float | datetime.timedelta | None = None\n    ) -&gt; AsyncIterator[asyncio.Task[Any]]:\n        \"\"\"Iterate over running tasks yielding as they complete.\n\n        Stops iterating when there are no more running tasks and all done tasks have\n        been acknowledged, or if the timeout is reached.\n\n        Note:\n            If an exception is raised while yielding a task, the task will be considered\n            not handled and will be yielded again until it is handled without raising\n            any exceptions.\n\n        Args:\n            timeout: The maximum time to wait for the next task to complete. If `None`,\n                the function will wait indefinitely.\n\n        Yields:\n            The tasks as they complete.\n        \"\"\"\n        while True:\n            while task := next(iter(self._waiting_ack), None):\n                yield task\n                # We discard instead of removing in case someone else already ACKed\n                # the task.\n                self._waiting_ack.discard(task)\n\n            if not self._running:\n                break\n\n            done, _ = await asyncio.wait(\n                self._running,\n                return_when=asyncio.FIRST_COMPLETED,\n                timeout=(\n                    timeout.total_seconds()\n                    if isinstance(timeout, datetime.timedelta)\n                    else timeout\n                ),\n            )\n\n            if not done:  # wait timed out\n                break\n\n            # We don't need to add done tasks to _waiting_ack, as they are added there\n            # automatically via add_done_callback().\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Enter an async context.\n\n        Returns:\n            This instance.\n        \"\"\"\n        return self\n\n    async def __aexit__(  # noqa: DOC502\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; bool | None:\n        \"\"\"Exit an async context.\n\n        Stop this instance.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exc_tb: The traceback of the exception raised, if any.\n\n        Returns:\n            Whether the exception was handled.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this group raised an\n                exception.\n        \"\"\"\n        await self.stop()\n        return None\n\n    async def _wait(self) -&gt; None:\n        \"\"\"Wait for this instance to finish.\n\n        Wait until all the group tasks are finished.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this group raised an\n                exception.\n        \"\"\"\n        exceptions: list[BaseException] = []\n\n        async for task in self.as_completed():\n            try:\n                await task\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n\n        if exceptions:\n            raise BaseExceptionGroup(f\"Error while stopping {self}\", exceptions)\n\n    def __await__(self) -&gt; Generator[None, None, None]:  # noqa: DOC502\n        \"\"\"Await for all tasks managed by this group to finish.\n\n        Returns:\n            An implementation-specific generator for the awaitable.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this group raised an\n                exception.\n        \"\"\"\n        return self._wait().__await__()\n\n    def __del__(self) -&gt; None:\n        \"\"\"Destroy this instance.\n\n        Cancel all running tasks spawned by this group.\n        \"\"\"\n        self.cancel(\"{self!r} was deleted\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        details = \"\"\n        if self._running:\n            details += f\" running={len(self._running)}\"\n        if self._waiting_ack:\n            details += f\" waiting_ack={len(self._waiting_ack)}\"\n        return f\"{type(self).__name__}&lt;{self.unique_id}{details}&gt;\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        return f\"{type(self).__name__}:{self._unique_id}\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Whether this task group is running.</p> <p>A task group is considered running when at least one task is running.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.task_creator","title":"task_creator  <code>property</code>","text":"<pre><code>task_creator: TaskCreator\n</code></pre> <p>The object that will be used to create tasks.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>The set of tasks managed by this group.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Both running tasks and tasks pending for acknowledgment are included in the returned set.</p> Danger <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.unique_id","title":"unique_id  <code>property</code>","text":"<pre><code>unique_id: str\n</code></pre> <p>The unique ID of this instance.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> RETURNS DESCRIPTION <code>Self</code> <p>This instance.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Returns:\n        This instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Exit an async context.</p> <p>Stop this instance.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> RETURNS DESCRIPTION <code>bool | None</code> <p>Whether the exception was handled.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this group raised an exception.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>async def __aexit__(  # noqa: DOC502\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; bool | None:\n    \"\"\"Exit an async context.\n\n    Stop this instance.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n\n    Returns:\n        Whether the exception was handled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this group raised an\n            exception.\n    \"\"\"\n    await self.stop()\n    return None\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await for all tasks managed by this group to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this group raised an exception.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>def __await__(self) -&gt; Generator[None, None, None]:  # noqa: DOC502\n    \"\"\"Await for all tasks managed by this group to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this group raised an\n            exception.\n    \"\"\"\n    return self._wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this group.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this group.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    unique_id: str | None = None,\n    task_creator: TaskCreator = asyncio\n) -&gt; None\n</code></pre> <p>Initialize this instance.</p> PARAMETER DESCRIPTION <code>unique_id</code> <p>The string to uniquely identify this instance. If <code>None</code>, a string based on <code>hex(id(self))</code> will be used. This is used in <code>__repr__</code> and <code>__str__</code> methods, mainly for debugging purposes, to identify a particular instance of a persistent task group.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>task_creator</code> <p>The object that will be used to create tasks. Usually one of: the <code>asyncio</code> module, an <code>asyncio.AbstractEventLoop</code> or an <code>asyncio.TaskGroup</code>.</p> <p> TYPE: <code>TaskCreator</code> DEFAULT: <code>asyncio</code> </p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>def __init__(\n    self, *, unique_id: str | None = None, task_creator: TaskCreator = asyncio\n) -&gt; None:\n    \"\"\"Initialize this instance.\n\n    Args:\n        unique_id: The string to uniquely identify this instance. If `None`,\n            a string based on `hex(id(self))` will be used. This is used in\n            `__repr__` and `__str__` methods, mainly for debugging purposes, to\n            identify a particular instance of a persistent task group.\n        task_creator: The object that will be used to create tasks. Usually one of:\n            the [`asyncio`]() module, an [`asyncio.AbstractEventLoop`]() or\n            an [`asyncio.TaskGroup`]().\n    \"\"\"\n    # [2:] is used to remove the '0x' prefix from the hex representation of the id,\n    # as it doesn't add any uniqueness to the string.\n    self._unique_id: str = hex(id(self))[2:] if unique_id is None else unique_id\n    \"\"\"The unique ID of this instance.\"\"\"\n\n    self._task_creator: TaskCreator = task_creator\n    \"\"\"The object that will be used to create tasks.\"\"\"\n\n    self._running: set[asyncio.Task[Any]] = set()\n    \"\"\"The set of tasks that are still running.\n\n    Tasks are removed from this set automatically when they finish using the\n    Task.add_done_callback method.\n    \"\"\"\n\n    self._waiting_ack: set[asyncio.Task[Any]] = set()\n    \"\"\"The set of tasks that have finished but waiting for the user's ACK.\n\n    Tasks are added to this set automatically when they finish using the\n    Task.add_done_callback method.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    details = \"\"\n    if self._running:\n        details += f\" running={len(self._running)}\"\n    if self._waiting_ack:\n        details += f\" waiting_ack={len(self._waiting_ack)}\"\n    return f\"{type(self).__name__}&lt;{self.unique_id}{details}&gt;\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}:{self._unique_id}\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.as_completed","title":"as_completed  <code>async</code>","text":"<pre><code>as_completed(\n    *, timeout: float | timedelta | None = None\n) -&gt; AsyncIterator[Task[Any]]\n</code></pre> <p>Iterate over running tasks yielding as they complete.</p> <p>Stops iterating when there are no more running tasks and all done tasks have been acknowledged, or if the timeout is reached.</p> Note <p>If an exception is raised while yielding a task, the task will be considered not handled and will be yielded again until it is handled without raising any exceptions.</p> PARAMETER DESCRIPTION <code>timeout</code> <p>The maximum time to wait for the next task to complete. If <code>None</code>, the function will wait indefinitely.</p> <p> TYPE: <code>float | timedelta | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[Task[Any]]</code> <p>The tasks as they complete.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>async def as_completed(\n    self, *, timeout: float | datetime.timedelta | None = None\n) -&gt; AsyncIterator[asyncio.Task[Any]]:\n    \"\"\"Iterate over running tasks yielding as they complete.\n\n    Stops iterating when there are no more running tasks and all done tasks have\n    been acknowledged, or if the timeout is reached.\n\n    Note:\n        If an exception is raised while yielding a task, the task will be considered\n        not handled and will be yielded again until it is handled without raising\n        any exceptions.\n\n    Args:\n        timeout: The maximum time to wait for the next task to complete. If `None`,\n            the function will wait indefinitely.\n\n    Yields:\n        The tasks as they complete.\n    \"\"\"\n    while True:\n        while task := next(iter(self._waiting_ack), None):\n            yield task\n            # We discard instead of removing in case someone else already ACKed\n            # the task.\n            self._waiting_ack.discard(task)\n\n        if not self._running:\n            break\n\n        done, _ = await asyncio.wait(\n            self._running,\n            return_when=asyncio.FIRST_COMPLETED,\n            timeout=(\n                timeout.total_seconds()\n                if isinstance(timeout, datetime.timedelta)\n                else timeout\n            ),\n        )\n\n        if not done:  # wait timed out\n            break\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this group.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this group.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._running:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.create_task","title":"create_task","text":"<pre><code>create_task(\n    coro: Coroutine[Any, Any, TaskReturnT],\n    *,\n    name: str | None = None,\n    context: Context | None = None,\n    log_exception: bool = True\n) -&gt; Task[TaskReturnT]\n</code></pre> <p>Start a managed task.</p> <p>A reference to the task will be held by the task group, so there is no need to save the task object.</p> <p>Tasks can be retrieved via the <code>tasks</code> property.</p> <p>Managed tasks always have a <code>name</code> including information about the task group itself. If you need to retrieve the final name of the task you can always do so by calling <code>.get_name()</code> on the returned task.</p> <p>Tasks created this way will also be automatically cancelled when calling <code>cancel()</code> or <code>stop()</code>, or when the service is used as a async context manager.</p> <p>To inform that a finished task was properly handled, the method <code>as_completed()</code> should be used.</p> PARAMETER DESCRIPTION <code>coro</code> <p>The coroutine to be managed.</p> <p> TYPE: <code>Coroutine[Any, Any, TaskReturnT]</code> </p> <code>name</code> <p>The name of the task. Names will always have the form <code>f\"{self}:{name}\"</code>. If <code>None</code> or empty, the default name will be <code>hex(id(coro))[2:]</code>. If you need the final name of the task, it can always be retrieved</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>context</code> <p>The context to be used for the task.</p> <p> TYPE: <code>Context | None</code> DEFAULT: <code>None</code> </p> <code>log_exception</code> <p>Whether to log exceptions raised by the task.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Task[TaskReturnT]</code> <p>The new task.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>def create_task(\n    self,\n    coro: Coroutine[Any, Any, TaskReturnT],\n    *,\n    name: str | None = None,\n    context: contextvars.Context | None = None,\n    log_exception: bool = True,\n) -&gt; asyncio.Task[TaskReturnT]:\n    \"\"\"Start a managed task.\n\n    A reference to the task will be held by the task group, so there is no need to\n    save the task object.\n\n    Tasks can be retrieved via the\n    [`tasks`][frequenz.core.asyncio.PersistentTaskGroup.tasks] property.\n\n    Managed tasks always have a `name` including information about the task group\n    itself. If you need to retrieve the final name of the task you can always do so\n    by calling [`.get_name()`][asyncio.Task.get_name] on the returned task.\n\n    Tasks created this way will also be automatically cancelled when calling\n    [`cancel()`][frequenz.core.asyncio.ServiceBase.cancel] or\n    [`stop()`][frequenz.core.asyncio.ServiceBase.stop], or when the service is used\n    as a async context manager.\n\n    To inform that a finished task was properly handled, the method\n    [`as_completed()`][frequenz.core.asyncio.PersistentTaskGroup.as_completed]\n    should be used.\n\n    Args:\n        coro: The coroutine to be managed.\n        name: The name of the task. Names will always have the form\n            `f\"{self}:{name}\"`. If `None` or empty, the default name will be\n            `hex(id(coro))[2:]`. If you need the final name of the task, it can\n            always be retrieved\n        context: The context to be used for the task.\n        log_exception: Whether to log exceptions raised by the task.\n\n    Returns:\n        The new task.\n    \"\"\"\n    if not name:\n        name = hex(id(coro))[2:]\n    task = self._task_creator.create_task(\n        coro, name=f\"{self}:{name}\", context=context\n    )\n    self._running.add(task)\n    task.add_done_callback(self._running.discard)\n    task.add_done_callback(self._waiting_ack.add)\n\n    if log_exception:\n\n        def _log_exception(task: asyncio.Task[TaskReturnT]) -&gt; None:\n            try:\n                task.result()\n            except asyncio.CancelledError:\n                pass\n            except BaseException:  # pylint: disable=broad-except\n                _logger.exception(\n                    \"Task %s raised an unhandled exception\", task.get_name()\n                )\n\n        task.add_done_callback(_log_exception)\n    return task\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.PersistentTaskGroup.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this task group.</p> <p>This method cancels all running tasks spawned by this group and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this group raised an exception.</p> Source code in <code>frequenz/core/asyncio/_task_group.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this task group.\n\n    This method cancels all running tasks spawned by this group and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this group raised an\n            exception.\n    \"\"\"\n    self.cancel(msg)\n    try:\n        await self\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service","title":"frequenz.core.asyncio.Service","text":"<p>               Bases: <code>ABC</code></p> <p>A service running in the background.</p> <p>A service swpawns one of more background tasks and can be started and stopped and can work as an async context manager to provide deterministic cleanup.</p> Warning <p>As services manage <code>asyncio.Task</code> objects, a reference to a running service must be held for as long as the service is expected to be running. Otherwise, its tasks will be cancelled and the service will stop. For more information, please refer to the Python <code>asyncio</code> documentation.</p> Example <pre><code>async def as_context_manager(service: Service) -&gt; None:\n    async with service:\n        assert service.is_running\n        await asyncio.sleep(5)\n    assert not service.is_running\n\nasync def manual_start_stop(service: Service) -&gt; None:\n    # Use only if necessary, as cleanup is more complicated\n    service.start()\n    await asyncio.sleep(5)\n    await service.stop()\n</code></pre> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>class Service(abc.ABC):\n    \"\"\"A service running in the background.\n\n    A service swpawns one of more background tasks and can be\n    [started][frequenz.core.asyncio.Service.start] and\n    [stopped][frequenz.core.asyncio.Service.stop] and can work as an async context\n    manager to provide deterministic cleanup.\n\n    Warning:\n        As services manage [`asyncio.Task`][] objects, a reference to a running service\n        must be held for as long as the service is expected to be running. Otherwise, its\n        tasks will be cancelled and the service will stop. For more information, please\n        refer to the [Python `asyncio`\n        documentation](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task).\n\n    Example:\n        ```python\n        async def as_context_manager(service: Service) -&gt; None:\n            async with service:\n                assert service.is_running\n                await asyncio.sleep(5)\n            assert not service.is_running\n\n        async def manual_start_stop(service: Service) -&gt; None:\n            # Use only if necessary, as cleanup is more complicated\n            service.start()\n            await asyncio.sleep(5)\n            await service.stop()\n        ```\n    \"\"\"\n\n    @abc.abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"Start this service.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def unique_id(self) -&gt; str:\n        \"\"\"The unique ID of this service.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def is_running(self) -&gt; bool:\n        \"\"\"Whether this service is running.\"\"\"\n\n    @abc.abstractmethod\n    def cancel(self, msg: str | None = None) -&gt; None:\n        \"\"\"Cancel this service.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n\n    @abc.abstractmethod\n    async def stop(self, msg: str | None = None) -&gt; None:  # noqa: DOC502\n        \"\"\"Stop this service.\n\n        This method cancels the service and waits for it to finish.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception.\n        \"\"\"\n\n    @abc.abstractmethod\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Enter an async context.\n\n        Start this service.\n\n        Returns:\n            This service.\n        \"\"\"\n\n    @abc.abstractmethod\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; bool | None:\n        \"\"\"Exit an async context.\n\n        Stop this service.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exc_tb: The traceback of the exception raised, if any.\n\n        Returns:\n            Whether the exception was handled.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __await__(self) -&gt; collections.abc.Generator[None, None, None]:  # noqa: DOC502\n        \"\"\"Wait for this service to finish.\n\n        Wait until all the service tasks are finished.\n\n        Returns:\n            An implementation-specific generator for the awaitable.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception (`CancelError` is not considered an error and not returned in\n                the exception group).\n        \"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service.is_running","title":"is_running  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Whether this service is running.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service.unique_id","title":"unique_id  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>unique_id: str\n</code></pre> <p>The unique ID of this service.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service.__aenter__","title":"__aenter__  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This service.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@abc.abstractmethod\nasync def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this service.\n\n    Returns:\n        This service.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service.__aexit__","title":"__aexit__  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Exit an async context.</p> <p>Stop this service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> RETURNS DESCRIPTION <code>bool | None</code> <p>Whether the exception was handled.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@abc.abstractmethod\nasync def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; bool | None:\n    \"\"\"Exit an async context.\n\n    Stop this service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n\n    Returns:\n        Whether the exception was handled.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service.__await__","title":"__await__  <code>abstractmethod</code>","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Wait for this service to finish.</p> <p>Wait until all the service tasks are finished.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@abc.abstractmethod\ndef __await__(self) -&gt; collections.abc.Generator[None, None, None]:  # noqa: DOC502\n    \"\"\"Wait for this service to finish.\n\n    Wait until all the service tasks are finished.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service.cancel","title":"cancel  <code>abstractmethod</code>","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel this service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@abc.abstractmethod\ndef cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel this service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this service.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@abc.abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"Start this service.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.Service.stop","title":"stop  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this service.</p> <p>This method cancels the service and waits for it to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@abc.abstractmethod\nasync def stop(self, msg: str | None = None) -&gt; None:  # noqa: DOC502\n    \"\"\"Stop this service.\n\n    This method cancels the service and waits for it to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase","title":"frequenz.core.asyncio.ServiceBase","text":"<p>               Bases: <code>Service</code>, <code>ABC</code></p> <p>A base class for implementing a service running in the background.</p> <p>To implement a service, subclasses must implement the <code>start()</code> method, which should start the background tasks needed by the service using the <code>create_task()</code> method.</p> <p>If you need to collect results or handle exceptions of the tasks when stopping the service, then you need to also override the <code>stop()</code> method, as the base implementation does not collect any results and re-raises all exceptions.</p> Simple single-task example <pre><code>import datetime\nimport asyncio\nfrom typing_extensions import override\n\nclass Clock(ServiceBase):\n    def __init__(self, resolution_s: float, *, unique_id: str | None = None) -&gt; None:\n        super().__init__(unique_id=unique_id)\n        self._resolution_s = resolution_s\n\n    @override\n    async def main(self) -&gt; None:\n        while True:\n            await asyncio.sleep(self._resolution_s)\n            print(datetime.datetime.now())\n\nasync def main() -&gt; None:\n    # As an async context manager\n    async with Clock(resolution_s=1):\n        await asyncio.sleep(5)\n\n    # Manual start/stop (only use if necessary, as cleanup is more complicated)\n    clock = Clock(resolution_s=1)\n    clock.start()\n    await asyncio.sleep(5)\n    await clock.stop()\n\nasyncio.run(main())\n</code></pre> Multi-tasks example <pre><code>import asyncio\nimport datetime\nfrom typing_extensions import override\n\nclass MultiTaskService(ServiceBase):\n\n    async def _print_every(self, *, seconds: float) -&gt; None:\n        while True:\n            await asyncio.sleep(seconds)\n            print(datetime.datetime.now())\n\n    async def _fail_after(self, *, seconds: float) -&gt; None:\n        await asyncio.sleep(seconds)\n        raise ValueError(\"I failed\")\n\n    @override\n    async def main(self) -&gt; None:\n        self.create_task(self._print_every(seconds=1), name=\"print_1\")\n        self.create_task(self._print_every(seconds=11), name=\"print_11\")\n        failing = self.create_task(self._fail_after(seconds=5), name=f\"fail_5\")\n\n        async for task in self.task_group.as_completed():\n            assert task.done()  # For demonstration purposes only\n            try:\n                task.result()\n            except ValueError as error:\n                if failing == task:\n                    failing = self.create_task(\n                        self._fail_after(seconds=5), name=f\"fail_5\"\n                    )\n                else:\n                    raise\n\nasync def main() -&gt; None:\n    async with MultiTaskService():\n        await asyncio.sleep(11)\n\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>class ServiceBase(Service, abc.ABC):\n    \"\"\"A base class for implementing a service running in the background.\n\n    To implement a service, subclasses must implement the\n    [`start()`][frequenz.core.asyncio.ServiceBase.start] method, which should start the\n    background tasks needed by the service using the\n    [`create_task()`][frequenz.core.asyncio.ServiceBase.create_task] method.\n\n    If you need to collect results or handle exceptions of the tasks when stopping the\n    service, then you need to also override the\n    [`stop()`][frequenz.core.asyncio.ServiceBase.stop] method, as the base\n    implementation does not collect any results and re-raises all exceptions.\n\n    Example: Simple single-task example\n        ```python\n        import datetime\n        import asyncio\n        from typing_extensions import override\n\n        class Clock(ServiceBase):\n            def __init__(self, resolution_s: float, *, unique_id: str | None = None) -&gt; None:\n                super().__init__(unique_id=unique_id)\n                self._resolution_s = resolution_s\n\n            @override\n            async def main(self) -&gt; None:\n                while True:\n                    await asyncio.sleep(self._resolution_s)\n                    print(datetime.datetime.now())\n\n        async def main() -&gt; None:\n            # As an async context manager\n            async with Clock(resolution_s=1):\n                await asyncio.sleep(5)\n\n            # Manual start/stop (only use if necessary, as cleanup is more complicated)\n            clock = Clock(resolution_s=1)\n            clock.start()\n            await asyncio.sleep(5)\n            await clock.stop()\n\n        asyncio.run(main())\n        ```\n\n    Example: Multi-tasks example\n        ```python\n        import asyncio\n        import datetime\n        from typing_extensions import override\n\n        class MultiTaskService(ServiceBase):\n\n            async def _print_every(self, *, seconds: float) -&gt; None:\n                while True:\n                    await asyncio.sleep(seconds)\n                    print(datetime.datetime.now())\n\n            async def _fail_after(self, *, seconds: float) -&gt; None:\n                await asyncio.sleep(seconds)\n                raise ValueError(\"I failed\")\n\n            @override\n            async def main(self) -&gt; None:\n                self.create_task(self._print_every(seconds=1), name=\"print_1\")\n                self.create_task(self._print_every(seconds=11), name=\"print_11\")\n                failing = self.create_task(self._fail_after(seconds=5), name=f\"fail_5\")\n\n                async for task in self.task_group.as_completed():\n                    assert task.done()  # For demonstration purposes only\n                    try:\n                        task.result()\n                    except ValueError as error:\n                        if failing == task:\n                            failing = self.create_task(\n                                self._fail_after(seconds=5), name=f\"fail_5\"\n                            )\n                        else:\n                            raise\n\n        async def main() -&gt; None:\n            async with MultiTaskService():\n                await asyncio.sleep(11)\n\n        asyncio.run(main())\n        ```\n\n    \"\"\"\n\n    def __init__(\n        self, *, unique_id: str | None = None, task_creator: TaskCreator = asyncio\n    ) -&gt; None:\n        \"\"\"Initialize this Service.\n\n        Args:\n            unique_id: The string to uniquely identify this service instance.\n                If `None`, a string based on `hex(id(self))` will be used. This is\n                used in `__repr__` and `__str__` methods, mainly for debugging\n                purposes, to identify a particular instance of a service.\n            task_creator: The object that will be used to create tasks. Usually one of:\n                the [`asyncio`]() module, an [`asyncio.AbstractEventLoop`]() or\n                an [`asyncio.TaskGroup`]().\n        \"\"\"\n        # [2:] is used to remove the '0x' prefix from the hex representation of the id,\n        # as it doesn't add any uniqueness to the string.\n        self._unique_id: str = hex(id(self))[2:] if unique_id is None else unique_id\n        self._main_task: asyncio.Task[None] | None = None\n        self._task_group: PersistentTaskGroup = PersistentTaskGroup(\n            unique_id=self._unique_id, task_creator=task_creator\n        )\n\n    @property\n    @override\n    def unique_id(self) -&gt; str:\n        \"\"\"The unique ID of this service.\"\"\"\n        return self._unique_id\n\n    @property\n    def task_group(self) -&gt; PersistentTaskGroup:\n        \"\"\"The task group managing the tasks of this service.\"\"\"\n        return self._task_group\n\n    @abc.abstractmethod\n    async def main(self) -&gt; None:\n        \"\"\"Execute the service logic.\"\"\"\n\n    @override\n    def start(self) -&gt; None:\n        \"\"\"Start this service.\"\"\"\n        if self.is_running:\n            return\n        self._main_task = self._task_group.task_creator.create_task(\n            self.main(), name=str(self)\n        )\n\n    @property\n    @override\n    def is_running(self) -&gt; bool:\n        \"\"\"Whether this service is running.\n\n        A service is considered running when at least one task is running.\n        \"\"\"\n        return self._main_task is not None and not self._main_task.done()\n\n    def create_task(\n        self,\n        coro: collections.abc.Coroutine[Any, Any, TaskReturnT],\n        *,\n        name: str | None = None,\n        context: contextvars.Context | None = None,\n        log_exception: bool = True,\n    ) -&gt; asyncio.Task[TaskReturnT]:\n        \"\"\"Start a managed task.\n\n        A reference to the task will be held by the service, so there is no need to save\n        the task object.\n\n        Tasks are created using the\n        [`task_group`][frequenz.core.asyncio.ServiceBase.task_group].\n\n        Managed tasks always have a `name` including information about the service\n        itself. If you need to retrieve the final name of the task you can always do so\n        by calling [`.get_name()`][asyncio.Task.get_name] on the returned task.\n\n        Tasks created this way will also be automatically cancelled when calling\n        [`cancel()`][frequenz.core.asyncio.ServiceBase.cancel] or\n        [`stop()`][frequenz.core.asyncio.ServiceBase.stop], or when the service is used\n        as a async context manager.\n\n        Args:\n            coro: The coroutine to be managed.\n            name: The name of the task. Names will always have the form\n                `f\"{self}:{name}\"`. If `None` or empty, the default name will be\n                `hex(id(coro))[2:]`. If you need the final name of the task, it can\n                always be retrieved\n            context: The context to be used for the task.\n            log_exception: Whether to log exceptions raised by the task.\n\n        Returns:\n            The new task.\n        \"\"\"\n        if not name:\n            name = hex(id(coro))[2:]\n        return self._task_group.create_task(\n            coro, name=f\"{self}:{name}\", context=context, log_exception=log_exception\n        )\n\n    @override\n    def cancel(self, msg: str | None = None) -&gt; None:\n        \"\"\"Cancel all running tasks spawned by this service.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        if self._main_task is not None:\n            self._main_task.cancel(msg)\n        self._task_group.cancel(msg)\n\n    @override\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this service.\n\n        This method cancels all running tasks spawned by this service and waits for them\n        to finish.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception.\n        \"\"\"\n        self.cancel(msg)\n        try:\n            await self\n        except BaseExceptionGroup as exc_group:\n            # We want to ignore CancelledError here as we explicitly cancelled all the\n            # tasks.\n            _, rest = exc_group.split(asyncio.CancelledError)\n            if rest is not None:\n                # We are filtering out from an exception group, we really don't want to\n                # add the exceptions we just filtered by adding a from clause here.\n                raise rest  # pylint: disable=raise-missing-from\n\n    @override\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Enter an async context.\n\n        Start this service.\n\n        Returns:\n            This service.\n        \"\"\"\n        self.start()\n        return self\n\n    @override\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; bool | None:\n        \"\"\"Exit an async context.\n\n        Stop this service.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exc_tb: The traceback of the exception raised, if any.\n\n        Returns:\n            Whether the exception was handled.\n        \"\"\"\n        await self.stop()\n        return None\n\n    async def _wait(self) -&gt; None:\n        \"\"\"Wait for this service to finish.\n\n        Wait until all the service tasks are finished.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception (`CancelError` is not considered an error and not returned in\n                the exception group).\n        \"\"\"\n        exceptions: list[BaseException] = []\n\n        if self._main_task is not None:\n            try:\n                await self._main_task\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n\n        try:\n            await self._task_group\n        except BaseExceptionGroup as exc_group:\n            exceptions.append(exc_group)\n\n        if exceptions:\n            raise BaseExceptionGroup(f\"Error while stopping {self}\", exceptions)\n\n    @override\n    def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n        \"\"\"Await this service.\n\n        An awaited service will wait for all its tasks to finish.\n\n        Returns:\n            An implementation-specific generator for the awaitable.\n        \"\"\"\n        return self._wait().__await__()\n\n    def __del__(self) -&gt; None:\n        \"\"\"Destroy this instance.\n\n        Cancel all running tasks spawned by this service.\n        \"\"\"\n        self.cancel(f\"{self!r} was deleted\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        details = \"main\"\n        if not self.is_running:\n            details += \" not\"\n        details += \" running\"\n        if self._task_group.is_running:\n            details += f\", {len(self._task_group.tasks)} extra tasks\"\n        return f\"{type(self).__name__}&lt;{self._unique_id} {details}&gt;\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        return f\"{type(self).__name__}:{self._unique_id}\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Whether this service is running.</p> <p>A service is considered running when at least one task is running.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.task_group","title":"task_group  <code>property</code>","text":"<pre><code>task_group: PersistentTaskGroup\n</code></pre> <p>The task group managing the tasks of this service.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.unique_id","title":"unique_id  <code>property</code>","text":"<pre><code>unique_id: str\n</code></pre> <p>The unique ID of this service.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This service.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@override\nasync def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this service.\n\n    Returns:\n        This service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Exit an async context.</p> <p>Stop this service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> RETURNS DESCRIPTION <code>bool | None</code> <p>Whether the exception was handled.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@override\nasync def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; bool | None:\n    \"\"\"Exit an async context.\n\n    Stop this service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n\n    Returns:\n        Whether the exception was handled.\n    \"\"\"\n    await self.stop()\n    return None\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this service.</p> <p>An awaited service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@override\ndef __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this service.\n\n    An awaited service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self._wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this service.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this service.\n    \"\"\"\n    self.cancel(f\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    unique_id: str | None = None,\n    task_creator: TaskCreator = asyncio\n) -&gt; None\n</code></pre> <p>Initialize this Service.</p> PARAMETER DESCRIPTION <code>unique_id</code> <p>The string to uniquely identify this service instance. If <code>None</code>, a string based on <code>hex(id(self))</code> will be used. This is used in <code>__repr__</code> and <code>__str__</code> methods, mainly for debugging purposes, to identify a particular instance of a service.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>task_creator</code> <p>The object that will be used to create tasks. Usually one of: the <code>asyncio</code> module, an <code>asyncio.AbstractEventLoop</code> or an <code>asyncio.TaskGroup</code>.</p> <p> TYPE: <code>TaskCreator</code> DEFAULT: <code>asyncio</code> </p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>def __init__(\n    self, *, unique_id: str | None = None, task_creator: TaskCreator = asyncio\n) -&gt; None:\n    \"\"\"Initialize this Service.\n\n    Args:\n        unique_id: The string to uniquely identify this service instance.\n            If `None`, a string based on `hex(id(self))` will be used. This is\n            used in `__repr__` and `__str__` methods, mainly for debugging\n            purposes, to identify a particular instance of a service.\n        task_creator: The object that will be used to create tasks. Usually one of:\n            the [`asyncio`]() module, an [`asyncio.AbstractEventLoop`]() or\n            an [`asyncio.TaskGroup`]().\n    \"\"\"\n    # [2:] is used to remove the '0x' prefix from the hex representation of the id,\n    # as it doesn't add any uniqueness to the string.\n    self._unique_id: str = hex(id(self))[2:] if unique_id is None else unique_id\n    self._main_task: asyncio.Task[None] | None = None\n    self._task_group: PersistentTaskGroup = PersistentTaskGroup(\n        unique_id=self._unique_id, task_creator=task_creator\n    )\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    details = \"main\"\n    if not self.is_running:\n        details += \" not\"\n    details += \" running\"\n    if self._task_group.is_running:\n        details += f\", {len(self._task_group.tasks)} extra tasks\"\n    return f\"{type(self).__name__}&lt;{self._unique_id} {details}&gt;\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}:{self._unique_id}\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@override\ndef cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    if self._main_task is not None:\n        self._main_task.cancel(msg)\n    self._task_group.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.create_task","title":"create_task","text":"<pre><code>create_task(\n    coro: Coroutine[Any, Any, TaskReturnT],\n    *,\n    name: str | None = None,\n    context: Context | None = None,\n    log_exception: bool = True\n) -&gt; Task[TaskReturnT]\n</code></pre> <p>Start a managed task.</p> <p>A reference to the task will be held by the service, so there is no need to save the task object.</p> <p>Tasks are created using the <code>task_group</code>.</p> <p>Managed tasks always have a <code>name</code> including information about the service itself. If you need to retrieve the final name of the task you can always do so by calling <code>.get_name()</code> on the returned task.</p> <p>Tasks created this way will also be automatically cancelled when calling <code>cancel()</code> or <code>stop()</code>, or when the service is used as a async context manager.</p> PARAMETER DESCRIPTION <code>coro</code> <p>The coroutine to be managed.</p> <p> TYPE: <code>Coroutine[Any, Any, TaskReturnT]</code> </p> <code>name</code> <p>The name of the task. Names will always have the form <code>f\"{self}:{name}\"</code>. If <code>None</code> or empty, the default name will be <code>hex(id(coro))[2:]</code>. If you need the final name of the task, it can always be retrieved</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>context</code> <p>The context to be used for the task.</p> <p> TYPE: <code>Context | None</code> DEFAULT: <code>None</code> </p> <code>log_exception</code> <p>Whether to log exceptions raised by the task.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Task[TaskReturnT]</code> <p>The new task.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>def create_task(\n    self,\n    coro: collections.abc.Coroutine[Any, Any, TaskReturnT],\n    *,\n    name: str | None = None,\n    context: contextvars.Context | None = None,\n    log_exception: bool = True,\n) -&gt; asyncio.Task[TaskReturnT]:\n    \"\"\"Start a managed task.\n\n    A reference to the task will be held by the service, so there is no need to save\n    the task object.\n\n    Tasks are created using the\n    [`task_group`][frequenz.core.asyncio.ServiceBase.task_group].\n\n    Managed tasks always have a `name` including information about the service\n    itself. If you need to retrieve the final name of the task you can always do so\n    by calling [`.get_name()`][asyncio.Task.get_name] on the returned task.\n\n    Tasks created this way will also be automatically cancelled when calling\n    [`cancel()`][frequenz.core.asyncio.ServiceBase.cancel] or\n    [`stop()`][frequenz.core.asyncio.ServiceBase.stop], or when the service is used\n    as a async context manager.\n\n    Args:\n        coro: The coroutine to be managed.\n        name: The name of the task. Names will always have the form\n            `f\"{self}:{name}\"`. If `None` or empty, the default name will be\n            `hex(id(coro))[2:]`. If you need the final name of the task, it can\n            always be retrieved\n        context: The context to be used for the task.\n        log_exception: Whether to log exceptions raised by the task.\n\n    Returns:\n        The new task.\n    \"\"\"\n    if not name:\n        name = hex(id(coro))[2:]\n    return self._task_group.create_task(\n        coro, name=f\"{self}:{name}\", context=context, log_exception=log_exception\n    )\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.main","title":"main  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Execute the service logic.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@abc.abstractmethod\nasync def main(self) -&gt; None:\n    \"\"\"Execute the service logic.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this service.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@override\ndef start(self) -&gt; None:\n    \"\"\"Start this service.\"\"\"\n    if self.is_running:\n        return\n    self._main_task = self._task_group.task_creator.create_task(\n        self.main(), name=str(self)\n    )\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.ServiceBase.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/core/asyncio/_service.py</code> <pre><code>@override\nasync def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    self.cancel(msg)\n    try:\n        await self\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.TaskCreator","title":"frequenz.core.asyncio.TaskCreator","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol for creating tasks.</p> <p>Built-in asyncio functions and classes implementing this protocol:</p> <ul> <li><code>asyncio</code></li> <li><code>asyncio.AbstractEventLoop</code> (returned by <code>asyncio.get_event_loop</code> for   example)</li> <li><code>asyncio.TaskGroup</code></li> </ul> Source code in <code>frequenz/core/asyncio/_util.py</code> <pre><code>@runtime_checkable\nclass TaskCreator(Protocol):\n    \"\"\"A protocol for creating tasks.\n\n    Built-in asyncio functions and classes implementing this protocol:\n\n    - [`asyncio`][]\n    - [`asyncio.AbstractEventLoop`][] (returned by [`asyncio.get_event_loop`][] for\n      example)\n    - [`asyncio.TaskGroup`][]\n    \"\"\"\n\n    def create_task(\n        self,\n        coro: collections.abc.Coroutine[Any, Any, TaskReturnT],\n        *,\n        name: str | None = None,\n        context: contextvars.Context | None = None,\n    ) -&gt; asyncio.Task[TaskReturnT]:\n        \"\"\"Create a task.\n\n        Args:\n            coro: The coroutine to be executed.\n            name: The name of the task.\n            context: The context to be used for the task.\n\n        Returns:\n            The new task.\n        \"\"\"\n        ...  # pylint: disable=unnecessary-ellipsis\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.TaskCreator-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.TaskCreator.create_task","title":"create_task","text":"<pre><code>create_task(\n    coro: Coroutine[Any, Any, TaskReturnT],\n    *,\n    name: str | None = None,\n    context: Context | None = None\n) -&gt; Task[TaskReturnT]\n</code></pre> <p>Create a task.</p> PARAMETER DESCRIPTION <code>coro</code> <p>The coroutine to be executed.</p> <p> TYPE: <code>Coroutine[Any, Any, TaskReturnT]</code> </p> <code>name</code> <p>The name of the task.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>context</code> <p>The context to be used for the task.</p> <p> TYPE: <code>Context | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Task[TaskReturnT]</code> <p>The new task.</p> Source code in <code>frequenz/core/asyncio/_util.py</code> <pre><code>def create_task(\n    self,\n    coro: collections.abc.Coroutine[Any, Any, TaskReturnT],\n    *,\n    name: str | None = None,\n    context: contextvars.Context | None = None,\n) -&gt; asyncio.Task[TaskReturnT]:\n    \"\"\"Create a task.\n\n    Args:\n        coro: The coroutine to be executed.\n        name: The name of the task.\n        context: The context to be used for the task.\n\n    Returns:\n        The new task.\n    \"\"\"\n    ...  # pylint: disable=unnecessary-ellipsis\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.cancel_and_await","title":"frequenz.core.asyncio.cancel_and_await  <code>async</code>","text":"<pre><code>cancel_and_await(task: Task[Any]) -&gt; None\n</code></pre> <p>Cancel a task and wait for it to finish.</p> <p>Exits immediately if the task is already done.</p> <p>The <code>CancelledError</code> is suppressed, but any other exception will be propagated.</p> PARAMETER DESCRIPTION <code>task</code> <p>The task to be cancelled and waited for.</p> <p> TYPE: <code>Task[Any]</code> </p> Source code in <code>frequenz/core/asyncio/_util.py</code> <pre><code>async def cancel_and_await(task: asyncio.Task[Any]) -&gt; None:\n    \"\"\"Cancel a task and wait for it to finish.\n\n    Exits immediately if the task is already done.\n\n    The `CancelledError` is suppressed, but any other exception will be propagated.\n\n    Args:\n        task: The task to be cancelled and waited for.\n    \"\"\"\n    if task.done():\n        return\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        pass\n</code></pre>"}]}