{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Core Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Core utilities to complement Python's standard library.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>For information on how to use this library, please refer to the documentation.</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Core Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>core<ul> <li>asyncio</li> <li>datetime</li> <li>math</li> <li>typing</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/core/","title":"Index","text":""},{"location":"reference/frequenz/core/#frequenz.core","title":"frequenz.core","text":"<p>Core utilities to complement Python's standard library.</p>"},{"location":"reference/frequenz/core/asyncio/","title":"asyncio","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio","title":"frequenz.core.asyncio","text":"<p>General purpose async tools.</p> <p>This module provides general purpose async tools that can be used to simplify the development of asyncio-based applications.</p> <p>The module provides the following classes and functions:</p> <ul> <li>cancel_and_await: A function that cancels a   task and waits for it to finish, handling <code>CancelledError</code> exceptions.</li> <li>BackgroundService: A base class for   implementing background services that can be started and stopped.</li> </ul>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio-classes","title":"Classes","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService","title":"frequenz.core.asyncio.BackgroundService","text":"<p>               Bases: <code>ABC</code></p> <p>A background service that can be started and stopped.</p> <p>A background service is a service that runs in the background spawning one or more tasks. The service can be started and stopped and can work as an async context manager to provide deterministic cleanup.</p> <p>To implement a background service, subclasses must implement the <code>start()</code> method, which should start the background tasks needed by the service, and add them to the <code>_tasks</code> protected attribute.</p> <p>If you need to collect results or handle exceptions of the tasks when stopping the service, then you need to also override the <code>stop()</code> method, as the base implementation does not collect any results and re-raises all exceptions.</p> <p>Warning</p> <p>As background services manage <code>asyncio.Task</code> objects, a reference to them must be held for as long as the background service is expected to be running, otherwise its tasks will be cancelled and the service will stop. For more information, please refer to the Python <code>asyncio</code> documentation.</p> Example <pre><code>import datetime\nimport asyncio\n\nclass Clock(BackgroundService):\n    def __init__(self, resolution_s: float, *, unique_id: str | None = None) -&gt; None:\n        super().__init__(unique_id=unique_id)\n        self._resolution_s = resolution_s\n\n    def start(self) -&gt; None:\n        self._tasks.add(asyncio.create_task(self._tick()))\n\n    async def _tick(self) -&gt; None:\n        while True:\n            await asyncio.sleep(self._resolution_s)\n            print(datetime.datetime.now())\n\nasync def main() -&gt; None:\n    # As an async context manager\n    async with Clock(resolution_s=1):\n        await asyncio.sleep(5)\n\n    # Manual start/stop (only use if necessary, as cleanup is more complicated)\n    clock = Clock(resolution_s=1)\n    clock.start()\n    await asyncio.sleep(5)\n    await clock.stop()\n\nasyncio.run(main())\n</code></pre> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>class BackgroundService(abc.ABC):\n    \"\"\"A background service that can be started and stopped.\n\n    A background service is a service that runs in the background spawning one or more\n    tasks. The service can be [started][frequenz.core.asyncio.BackgroundService.start]\n    and [stopped][frequenz.core.asyncio.BackgroundService.stop] and can work as an\n    async context manager to provide deterministic cleanup.\n\n    To implement a background service, subclasses must implement the\n    [`start()`][frequenz.core.asyncio.BackgroundService.start] method, which should\n    start the background tasks needed by the service, and add them to the `_tasks`\n    protected attribute.\n\n    If you need to collect results or handle exceptions of the tasks when stopping the\n    service, then you need to also override the\n    [`stop()`][frequenz.core.asyncio.BackgroundService.stop] method, as the base\n    implementation does not collect any results and re-raises all exceptions.\n\n    !!! warning\n\n        As background services manage [`asyncio.Task`][] objects, a reference to them\n        must be held for as long as the background service is expected to be running,\n        otherwise its tasks will be cancelled and the service will stop. For more\n        information, please refer to the [Python `asyncio`\n        documentation](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task).\n\n    Example:\n        ```python\n        import datetime\n        import asyncio\n\n        class Clock(BackgroundService):\n            def __init__(self, resolution_s: float, *, unique_id: str | None = None) -&gt; None:\n                super().__init__(unique_id=unique_id)\n                self._resolution_s = resolution_s\n\n            def start(self) -&gt; None:\n                self._tasks.add(asyncio.create_task(self._tick()))\n\n            async def _tick(self) -&gt; None:\n                while True:\n                    await asyncio.sleep(self._resolution_s)\n                    print(datetime.datetime.now())\n\n        async def main() -&gt; None:\n            # As an async context manager\n            async with Clock(resolution_s=1):\n                await asyncio.sleep(5)\n\n            # Manual start/stop (only use if necessary, as cleanup is more complicated)\n            clock = Clock(resolution_s=1)\n            clock.start()\n            await asyncio.sleep(5)\n            await clock.stop()\n\n        asyncio.run(main())\n        ```\n    \"\"\"\n\n    def __init__(self, *, unique_id: str | None = None) -&gt; None:\n        \"\"\"Initialize this BackgroundService.\n\n        Args:\n            unique_id: The string to uniquely identify this background service instance.\n                If `None`, a string based on `hex(id(self))` will be used. This is\n                used in `__repr__` and `__str__` methods, mainly for debugging\n                purposes, to identify a particular instance of a background service.\n        \"\"\"\n        # [2:] is used to remove the '0x' prefix from the hex representation of the id,\n        # as it doesn't add any uniqueness to the string.\n        self._unique_id: str = hex(id(self))[2:] if unique_id is None else unique_id\n        self._tasks: set[asyncio.Task[Any]] = set()\n\n    @abc.abstractmethod\n    def start(self) -&gt; None:\n        \"\"\"Start this background service.\"\"\"\n\n    @property\n    def unique_id(self) -&gt; str:\n        \"\"\"The unique ID of this background service.\n\n        Returns:\n            The unique ID of this background service.\n        \"\"\"\n        return self._unique_id\n\n    @property\n    def tasks(self) -&gt; collections.abc.Set[asyncio.Task[Any]]:\n        \"\"\"Return the set of running tasks spawned by this background service.\n\n        Users typically should not modify the tasks in the returned set and only use\n        them for informational purposes.\n\n        !!! danger\n\n            Changing the returned tasks may lead to unexpected behavior, don't do it\n            unless the class explicitly documents it is safe to do so.\n\n        Returns:\n            The set of running tasks spawned by this background service.\n        \"\"\"\n        return self._tasks\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Return whether this background service is running.\n\n        A service is considered running when at least one task is running.\n\n        Returns:\n            Whether this background service is running.\n        \"\"\"\n        return any(not task.done() for task in self._tasks)\n\n    def cancel(self, msg: str | None = None) -&gt; None:\n        \"\"\"Cancel all running tasks spawned by this background service.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n        \"\"\"\n        for task in self._tasks:\n            task.cancel(msg)\n\n    async def stop(self, msg: str | None = None) -&gt; None:\n        \"\"\"Stop this background service.\n\n        This method cancels all running tasks spawned by this service and waits for them\n        to finish.\n\n        Args:\n            msg: The message to be passed to the tasks being cancelled.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception.\n        \"\"\"\n        if not self._tasks:\n            return\n        self.cancel(msg)\n        try:\n            await self.wait()\n        except BaseExceptionGroup as exc_group:\n            # We want to ignore CancelledError here as we explicitly cancelled all the\n            # tasks.\n            _, rest = exc_group.split(asyncio.CancelledError)\n            if rest is not None:\n                # We are filtering out from an exception group, we really don't want to\n                # add the exceptions we just filtered by adding a from clause here.\n                raise rest  # pylint: disable=raise-missing-from\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"Enter an async context.\n\n        Start this background service.\n\n        Returns:\n            This background service.\n        \"\"\"\n        self.start()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit an async context.\n\n        Stop this background service.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exc_tb: The traceback of the exception raised, if any.\n        \"\"\"\n        await self.stop()\n\n    async def wait(self) -&gt; None:\n        \"\"\"Wait this background service to finish.\n\n        Wait until all background service tasks are finished.\n\n        Raises:\n            BaseExceptionGroup: If any of the tasks spawned by this service raised an\n                exception (`CancelError` is not considered an error and not returned in\n                the exception group).\n        \"\"\"\n        # We need to account for tasks that were created between when we started\n        # awaiting and we finished awaiting.\n        while self._tasks:\n            done, pending = await asyncio.wait(self._tasks)\n            assert not pending\n\n            # We remove the done tasks, but there might be new ones created after we\n            # started waiting.\n            self._tasks = self._tasks - done\n\n            exceptions: list[BaseException] = []\n            for task in done:\n                try:\n                    # This will raise a CancelledError if the task was cancelled or any\n                    # other exception if the task raised one.\n                    _ = task.result()\n                except BaseException as error:  # pylint: disable=broad-except\n                    exceptions.append(error)\n            if exceptions:\n                raise BaseExceptionGroup(\n                    f\"Error while stopping background service {self}\", exceptions\n                )\n\n    def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n        \"\"\"Await this background service.\n\n        An awaited background service will wait for all its tasks to finish.\n\n        Returns:\n            An implementation-specific generator for the awaitable.\n        \"\"\"\n        return self.wait().__await__()\n\n    def __del__(self) -&gt; None:\n        \"\"\"Destroy this instance.\n\n        Cancel all running tasks spawned by this background service.\n        \"\"\"\n        self.cancel(\"{self!r} was deleted\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        return f\"{type(self).__name__}(unique_id={self._unique_id!r}, tasks={self._tasks!r})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\n\n        Returns:\n            A string representation of this instance.\n        \"\"\"\n        return f\"{type(self).__name__}[{self._unique_id}]\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.is_running","title":"is_running  <code>property</code>","text":"<pre><code>is_running: bool\n</code></pre> <p>Return whether this background service is running.</p> <p>A service is considered running when at least one task is running.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether this background service is running.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.tasks","title":"tasks  <code>property</code>","text":"<pre><code>tasks: Set[Task[Any]]\n</code></pre> <p>Return the set of running tasks spawned by this background service.</p> <p>Users typically should not modify the tasks in the returned set and only use them for informational purposes.</p> <p>Danger</p> <p>Changing the returned tasks may lead to unexpected behavior, don't do it unless the class explicitly documents it is safe to do so.</p> RETURNS DESCRIPTION <code>Set[Task[Any]]</code> <p>The set of running tasks spawned by this background service.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.unique_id","title":"unique_id  <code>property</code>","text":"<pre><code>unique_id: str\n</code></pre> <p>The unique ID of this background service.</p> RETURNS DESCRIPTION <code>str</code> <p>The unique ID of this background service.</p>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> <p>Enter an async context.</p> <p>Start this background service.</p> RETURNS DESCRIPTION <code>Self</code> <p>This background service.</p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    \"\"\"Enter an async context.\n\n    Start this background service.\n\n    Returns:\n        This background service.\n    \"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None\n</code></pre> <p>Exit an async context.</p> <p>Stop this background service.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the exception raised, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception raised, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback of the exception raised, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_val: BaseException | None,\n    exc_tb: TracebackType | None,\n) -&gt; None:\n    \"\"\"Exit an async context.\n\n    Stop this background service.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exc_tb: The traceback of the exception raised, if any.\n    \"\"\"\n    await self.stop()\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.__await__","title":"__await__","text":"<pre><code>__await__() -&gt; Generator[None, None, None]\n</code></pre> <p>Await this background service.</p> <p>An awaited background service will wait for all its tasks to finish.</p> RETURNS DESCRIPTION <code>Generator[None, None, None]</code> <p>An implementation-specific generator for the awaitable.</p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>def __await__(self) -&gt; collections.abc.Generator[None, None, None]:\n    \"\"\"Await this background service.\n\n    An awaited background service will wait for all its tasks to finish.\n\n    Returns:\n        An implementation-specific generator for the awaitable.\n    \"\"\"\n    return self.wait().__await__()\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.__del__","title":"__del__","text":"<pre><code>__del__() -&gt; None\n</code></pre> <p>Destroy this instance.</p> <p>Cancel all running tasks spawned by this background service.</p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>def __del__(self) -&gt; None:\n    \"\"\"Destroy this instance.\n\n    Cancel all running tasks spawned by this background service.\n    \"\"\"\n    self.cancel(\"{self!r} was deleted\")\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.__init__","title":"__init__","text":"<pre><code>__init__(*, unique_id: str | None = None) -&gt; None\n</code></pre> <p>Initialize this BackgroundService.</p> PARAMETER DESCRIPTION <code>unique_id</code> <p>The string to uniquely identify this background service instance. If <code>None</code>, a string based on <code>hex(id(self))</code> will be used. This is used in <code>__repr__</code> and <code>__str__</code> methods, mainly for debugging purposes, to identify a particular instance of a background service.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>def __init__(self, *, unique_id: str | None = None) -&gt; None:\n    \"\"\"Initialize this BackgroundService.\n\n    Args:\n        unique_id: The string to uniquely identify this background service instance.\n            If `None`, a string based on `hex(id(self))` will be used. This is\n            used in `__repr__` and `__str__` methods, mainly for debugging\n            purposes, to identify a particular instance of a background service.\n    \"\"\"\n    # [2:] is used to remove the '0x' prefix from the hex representation of the id,\n    # as it doesn't add any uniqueness to the string.\n    self._unique_id: str = hex(id(self))[2:] if unique_id is None else unique_id\n    self._tasks: set[asyncio.Task[Any]] = set()\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}(unique_id={self._unique_id!r}, tasks={self._tasks!r})\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of this instance.</p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\n\n    Returns:\n        A string representation of this instance.\n    \"\"\"\n    return f\"{type(self).__name__}[{self._unique_id}]\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.cancel","title":"cancel","text":"<pre><code>cancel(msg: str | None = None) -&gt; None\n</code></pre> <p>Cancel all running tasks spawned by this background service.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>def cancel(self, msg: str | None = None) -&gt; None:\n    \"\"\"Cancel all running tasks spawned by this background service.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n    \"\"\"\n    for task in self._tasks:\n        task.cancel(msg)\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.start","title":"start  <code>abstractmethod</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start this background service.</p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>@abc.abstractmethod\ndef start(self) -&gt; None:\n    \"\"\"Start this background service.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.stop","title":"stop  <code>async</code>","text":"<pre><code>stop(msg: str | None = None) -&gt; None\n</code></pre> <p>Stop this background service.</p> <p>This method cancels all running tasks spawned by this service and waits for them to finish.</p> PARAMETER DESCRIPTION <code>msg</code> <p>The message to be passed to the tasks being cancelled.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception.</p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>async def stop(self, msg: str | None = None) -&gt; None:\n    \"\"\"Stop this background service.\n\n    This method cancels all running tasks spawned by this service and waits for them\n    to finish.\n\n    Args:\n        msg: The message to be passed to the tasks being cancelled.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception.\n    \"\"\"\n    if not self._tasks:\n        return\n    self.cancel(msg)\n    try:\n        await self.wait()\n    except BaseExceptionGroup as exc_group:\n        # We want to ignore CancelledError here as we explicitly cancelled all the\n        # tasks.\n        _, rest = exc_group.split(asyncio.CancelledError)\n        if rest is not None:\n            # We are filtering out from an exception group, we really don't want to\n            # add the exceptions we just filtered by adding a from clause here.\n            raise rest  # pylint: disable=raise-missing-from\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.BackgroundService.wait","title":"wait  <code>async</code>","text":"<pre><code>wait() -&gt; None\n</code></pre> <p>Wait this background service to finish.</p> <p>Wait until all background service tasks are finished.</p> RAISES DESCRIPTION <code>BaseExceptionGroup</code> <p>If any of the tasks spawned by this service raised an exception (<code>CancelError</code> is not considered an error and not returned in the exception group).</p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>async def wait(self) -&gt; None:\n    \"\"\"Wait this background service to finish.\n\n    Wait until all background service tasks are finished.\n\n    Raises:\n        BaseExceptionGroup: If any of the tasks spawned by this service raised an\n            exception (`CancelError` is not considered an error and not returned in\n            the exception group).\n    \"\"\"\n    # We need to account for tasks that were created between when we started\n    # awaiting and we finished awaiting.\n    while self._tasks:\n        done, pending = await asyncio.wait(self._tasks)\n        assert not pending\n\n        # We remove the done tasks, but there might be new ones created after we\n        # started waiting.\n        self._tasks = self._tasks - done\n\n        exceptions: list[BaseException] = []\n        for task in done:\n            try:\n                # This will raise a CancelledError if the task was cancelled or any\n                # other exception if the task raised one.\n                _ = task.result()\n            except BaseException as error:  # pylint: disable=broad-except\n                exceptions.append(error)\n        if exceptions:\n            raise BaseExceptionGroup(\n                f\"Error while stopping background service {self}\", exceptions\n            )\n</code></pre>"},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/asyncio/#frequenz.core.asyncio.cancel_and_await","title":"frequenz.core.asyncio.cancel_and_await  <code>async</code>","text":"<pre><code>cancel_and_await(task: Task[Any]) -&gt; None\n</code></pre> <p>Cancel a task and wait for it to finish.</p> <p>Exits immediately if the task is already done.</p> <p>The <code>CancelledError</code> is suppressed, but any other exception will be propagated.</p> PARAMETER DESCRIPTION <code>task</code> <p>The task to be cancelled and waited for.</p> <p> TYPE: <code>Task[Any]</code> </p> Source code in <code>frequenz/core/asyncio.py</code> <pre><code>async def cancel_and_await(task: asyncio.Task[Any]) -&gt; None:\n    \"\"\"Cancel a task and wait for it to finish.\n\n    Exits immediately if the task is already done.\n\n    The `CancelledError` is suppressed, but any other exception will be propagated.\n\n    Args:\n        task: The task to be cancelled and waited for.\n    \"\"\"\n    if task.done():\n        return\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        pass\n</code></pre>"},{"location":"reference/frequenz/core/datetime/","title":"datetime","text":""},{"location":"reference/frequenz/core/datetime/#frequenz.core.datetime","title":"frequenz.core.datetime","text":"<p>Timeseries basic types.</p>"},{"location":"reference/frequenz/core/datetime/#frequenz.core.datetime-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/datetime/#frequenz.core.datetime.UNIX_EPOCH","title":"frequenz.core.datetime.UNIX_EPOCH  <code>module-attribute</code>","text":"<pre><code>UNIX_EPOCH = fromtimestamp(0.0, tz=utc)\n</code></pre> <p>The UNIX epoch (in UTC).</p>"},{"location":"reference/frequenz/core/math/","title":"math","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math","title":"frequenz.core.math","text":"<p>Math tools.</p>"},{"location":"reference/frequenz/core/math/#frequenz.core.math-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.LessThanComparableOrNoneT","title":"frequenz.core.math.LessThanComparableOrNoneT  <code>module-attribute</code>","text":"<pre><code>LessThanComparableOrNoneT = TypeVar(\n    \"LessThanComparableOrNoneT\",\n    bound=LessThanComparable | None,\n)\n</code></pre> <p>Type variable for a value that a <code>LessThanComparable</code> or <code>None</code>.</p>"},{"location":"reference/frequenz/core/math/#frequenz.core.math-classes","title":"Classes","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval","title":"frequenz.core.math.Interval  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[LessThanComparableOrNoneT]</code></p> <p>An interval to test if a value is within its limits.</p> <p>The <code>start</code> and <code>end</code> are inclusive, meaning that the <code>start</code> and <code>end</code> limites are included in the range when checking if a value is contained by the interval.</p> <p>If the <code>start</code> or <code>end</code> is <code>None</code>, it means that the interval is unbounded in that direction.</p> <p>If <code>start</code> is bigger than <code>end</code>, a <code>ValueError</code> is raised.</p> <p>The type stored in the interval must be comparable, meaning that it must implement the <code>__lt__</code> method to be able to compare values.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>@dataclass(frozen=True, repr=False)\nclass Interval(Generic[LessThanComparableOrNoneT]):\n    \"\"\"An interval to test if a value is within its limits.\n\n    The `start` and `end` are inclusive, meaning that the `start` and `end` limites are\n    included in the range when checking if a value is contained by the interval.\n\n    If the `start` or `end` is `None`, it means that the interval is unbounded in that\n    direction.\n\n    If `start` is bigger than `end`, a `ValueError` is raised.\n\n    The type stored in the interval must be comparable, meaning that it must implement\n    the `__lt__` method to be able to compare values.\n    \"\"\"\n\n    start: LessThanComparableOrNoneT\n    \"\"\"The start of the interval.\"\"\"\n\n    end: LessThanComparableOrNoneT\n    \"\"\"The end of the interval.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Check if the start is less than or equal to the end.\"\"\"\n        if self.start is None or self.end is None:\n            return\n        start = cast(LessThanComparable, self.start)\n        end = cast(LessThanComparable, self.end)\n        if start &gt; end:\n            raise ValueError(\n                f\"The start ({self.start}) can't be bigger than end ({self.end})\"\n            )\n\n    def __contains__(self, item: LessThanComparableOrNoneT) -&gt; bool:\n        \"\"\"\n        Check if the value is within the range of the container.\n\n        Args:\n            item: The value to check.\n\n        Returns:\n            bool: True if value is within the range, otherwise False.\n        \"\"\"\n        if item is None:\n            return False\n        casted_item = cast(LessThanComparable, item)\n\n        if self.start is None and self.end is None:\n            return True\n        if self.start is None:\n            start = cast(LessThanComparable, self.end)\n            return not casted_item &gt; start\n        if self.end is None:\n            return not self.start &gt; item\n        # mypy seems to get confused here, not being able to narrow start and end to\n        # just LessThanComparable, complaining with:\n        #   error: Unsupported left operand type for &lt;= (some union)\n        # But we know if they are not None, they should be LessThanComparable, and\n        # actually mypy is being able to figure it out in the lines above, just not in\n        # this one, so it should be safe to cast.\n        return not (\n            casted_item &lt; cast(LessThanComparable, self.start)\n            or casted_item &gt; cast(LessThanComparable, self.end)\n        )\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\"\"\"\n        return f\"Interval({self.start!r}, {self.end!r})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of this instance.\"\"\"\n        start = \"\u221e\" if self.start is None else str(self.start)\n        end = \"\u221e\" if self.end is None else str(self.end)\n        return f\"[{start}, {end}]\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.end","title":"end  <code>instance-attribute</code>","text":"<pre><code>end: LessThanComparableOrNoneT\n</code></pre> <p>The end of the interval.</p>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: LessThanComparableOrNoneT\n</code></pre> <p>The start of the interval.</p>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: LessThanComparableOrNoneT) -&gt; bool\n</code></pre> <p>Check if the value is within the range of the container.</p> PARAMETER DESCRIPTION <code>item</code> <p>The value to check.</p> <p> TYPE: <code>LessThanComparableOrNoneT</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if value is within the range, otherwise False.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __contains__(self, item: LessThanComparableOrNoneT) -&gt; bool:\n    \"\"\"\n    Check if the value is within the range of the container.\n\n    Args:\n        item: The value to check.\n\n    Returns:\n        bool: True if value is within the range, otherwise False.\n    \"\"\"\n    if item is None:\n        return False\n    casted_item = cast(LessThanComparable, item)\n\n    if self.start is None and self.end is None:\n        return True\n    if self.start is None:\n        start = cast(LessThanComparable, self.end)\n        return not casted_item &gt; start\n    if self.end is None:\n        return not self.start &gt; item\n    # mypy seems to get confused here, not being able to narrow start and end to\n    # just LessThanComparable, complaining with:\n    #   error: Unsupported left operand type for &lt;= (some union)\n    # But we know if they are not None, they should be LessThanComparable, and\n    # actually mypy is being able to figure it out in the lines above, just not in\n    # this one, so it should be safe to cast.\n    return not (\n        casted_item &lt; cast(LessThanComparable, self.start)\n        or casted_item &gt; cast(LessThanComparable, self.end)\n    )\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Check if the start is less than or equal to the end.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Check if the start is less than or equal to the end.\"\"\"\n    if self.start is None or self.end is None:\n        return\n    start = cast(LessThanComparable, self.start)\n    end = cast(LessThanComparable, self.end)\n    if start &gt; end:\n        raise ValueError(\n            f\"The start ({self.start}) can't be bigger than end ({self.end})\"\n        )\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\"\"\"\n    return f\"Interval({self.start!r}, {self.end!r})\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.Interval.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return a string representation of this instance.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of this instance.\"\"\"\n    start = \"\u221e\" if self.start is None else str(self.start)\n    end = \"\u221e\" if self.end is None else str(self.end)\n    return f\"[{start}, {end}]\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.LessThanComparable","title":"frequenz.core.math.LessThanComparable","text":"<p>               Bases: <code>Protocol</code></p> <p>A protocol that requires the <code>__lt__</code> method to compare values.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>class LessThanComparable(Protocol):\n    \"\"\"A protocol that requires the `__lt__` method to compare values.\"\"\"\n\n    def __lt__(self, other: Self, /) -&gt; bool:\n        \"\"\"Return whether self is less than other.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math.LessThanComparable-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.LessThanComparable.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: Self) -&gt; bool\n</code></pre> <p>Return whether self is less than other.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def __lt__(self, other: Self, /) -&gt; bool:\n    \"\"\"Return whether self is less than other.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/core/math/#frequenz.core.math-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/math/#frequenz.core.math.is_close_to_zero","title":"frequenz.core.math.is_close_to_zero","text":"<pre><code>is_close_to_zero(\n    value: float, abs_tol: float = 1e-09\n) -&gt; bool\n</code></pre> <p>Check if a floating point value is close to zero.</p> <p>A value of 1e-9 is a commonly used absolute tolerance to balance precision and robustness for floating-point numbers comparisons close to zero. Note that this is also the default value for the relative tolerance. For more technical details, see https://peps.python.org/pep-0485/#behavior-near-zero</p> PARAMETER DESCRIPTION <code>value</code> <p>The floating point value to compare to.</p> <p> TYPE: <code>float</code> </p> <code>abs_tol</code> <p>The minimum absolute tolerance. Defaults to 1e-9.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1e-09</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the floating point value is close to zero.</p> Source code in <code>frequenz/core/math.py</code> <pre><code>def is_close_to_zero(value: float, abs_tol: float = 1e-9) -&gt; bool:\n    \"\"\"Check if a floating point value is close to zero.\n\n    A value of 1e-9 is a commonly used absolute tolerance to balance precision\n    and robustness for floating-point numbers comparisons close to zero. Note\n    that this is also the default value for the relative tolerance.\n    For more technical details, see https://peps.python.org/pep-0485/#behavior-near-zero\n\n    Args:\n        value: The floating point value to compare to.\n        abs_tol: The minimum absolute tolerance. Defaults to 1e-9.\n\n    Returns:\n        Whether the floating point value is close to zero.\n    \"\"\"\n    zero: float = 0.0\n    return math.isclose(a=value, b=zero, abs_tol=abs_tol)\n</code></pre>"},{"location":"reference/frequenz/core/typing/","title":"typing","text":""},{"location":"reference/frequenz/core/typing/#frequenz.core.typing","title":"frequenz.core.typing","text":"<p>Type hints and utility functions for type checking and types.</p> <p>For now this module only provides a decorator to disable the <code>__init__</code> constructor of a class, to force the use of a factory method to create instances. See disable_init for more information.</p>"},{"location":"reference/frequenz/core/typing/#frequenz.core.typing-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/core/typing/#frequenz.core.typing.TypeT","title":"frequenz.core.typing.TypeT  <code>module-attribute</code>","text":"<pre><code>TypeT = TypeVar('TypeT', bound=type)\n</code></pre> <p>A type variable that is bound to a type.</p>"},{"location":"reference/frequenz/core/typing/#frequenz.core.typing-functions","title":"Functions","text":""},{"location":"reference/frequenz/core/typing/#frequenz.core.typing.disable_init","title":"frequenz.core.typing.disable_init","text":"<pre><code>disable_init(\n    cls: TypeT | None = None,\n    *,\n    error: Exception | None = None\n) -&gt; TypeT | Callable[[TypeT], TypeT]\n</code></pre> <p>Disable the <code>__init__</code> constructor of a class.</p> <p>This decorator can be used to disable the <code>__init__</code> constructor of a class. It is intended to be used with classes that don't provide a default constructor and require the use of a factory method to create instances.</p> <p>When marking a class with this decorator, the class cannot be even declared with a <code>__init__</code> method, as it will raise a <code>TypeError</code> when the class is created, as soon as the class is parsed by the Python interpreter. It will also raise a <code>TypeError</code> when the <code>__init__</code> method is called.</p> <p>To create an instance you must provide a factory method, using <code>__new__</code>.</p> Warning <p>This decorator will use a custom metaclass to disable the <code>__init__</code> constructor of the class, so if your class already uses a custom metaclass, you should be aware of potential conflicts.</p> Basic example defining a class with a factory method <p>To be able to type hint the class correctly, you can declare the instance attributes in the class body, and then use a factory method to create instances.</p> <pre><code>from typing import Self\n\n@disable_init\nclass MyClass:\n    value: int\n\n    @classmethod\n    def new(cls, value: int = 1) -&gt; Self:\n        self = cls.__new__(cls)\n        self.value = value\n        return self\n\ninstance = MyClass.new()\n\n# Calling the default constructor (__init__) will raise a TypeError\ntry:\n    instance = MyClass()\nexcept TypeError as e:\n    print(e)\n</code></pre> Class wrongly providing an <code>__init__</code> constructor <pre><code>try:\n    @disable_init\n    class MyClass:\n        def __init__(self) -&gt; None:\n            pass\nexcept TypeError as e:\n    assert isinstance(e, TypeError)\n    print(e)\n</code></pre> Using a custom error message when the default constructor is called <pre><code>from typing import Self\n\nclass NoInitError(TypeError):\n    def __init__(self) -&gt; None:\n        super().__init__(\"Please create instances of MyClass using MyClass.new()\")\n\n@disable_init(error=NoInitError())\nclass MyClass:\n    @classmethod\n    def new(cls) -&gt; Self:\n        return cls.__new__(cls)\n\ntry:\n    instance = MyClass()\nexcept NoInitError as e:\n    assert str(e) == \"Please create instances of MyClass using MyClass.new()\"\n    print(e)\n</code></pre> PARAMETER DESCRIPTION <code>cls</code> <p>The class to be decorated.</p> <p> TYPE: <code>TypeT | None</code> DEFAULT: <code>None</code> </p> <code>error</code> <p>The error to raise if init is called, if <code>None</code> a default TypeError will be raised.</p> <p> TYPE: <code>Exception | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>TypeT | Callable[[TypeT], TypeT]</code> <p>A decorator that disables the <code>__init__</code> constructor of <code>cls</code>.</p> Source code in <code>frequenz/core/typing.py</code> <pre><code>def disable_init(\n    cls: TypeT | None = None,\n    *,\n    error: Exception | None = None,\n) -&gt; TypeT | Callable[[TypeT], TypeT]:\n    \"\"\"Disable the `__init__` constructor of a class.\n\n    This decorator can be used to disable the `__init__` constructor of a class. It is\n    intended to be used with classes that don't provide a default constructor and\n    require the use of a factory method to create instances.\n\n    When marking a class with this decorator, the class cannot be even declared with a\n    `__init__` method, as it will raise a `TypeError` when the class is created, as soon\n    as the class is parsed by the Python interpreter. It will also raise a `TypeError`\n    when the `__init__` method is called.\n\n    To create an instance you must provide a factory method, using `__new__`.\n\n    Warning:\n        This decorator will use a custom metaclass to disable the `__init__` constructor\n        of the class, so if your class already uses a custom metaclass, you should be\n        aware of potential conflicts.\n\n    Example: Basic example defining a class with a factory method\n        To be able to type hint the class correctly, you can declare the instance\n        attributes in the class body, and then use a factory method to create instances.\n\n        ```python\n        from typing import Self\n\n        @disable_init\n        class MyClass:\n            value: int\n\n            @classmethod\n            def new(cls, value: int = 1) -&gt; Self:\n                self = cls.__new__(cls)\n                self.value = value\n                return self\n\n        instance = MyClass.new()\n\n        # Calling the default constructor (__init__) will raise a TypeError\n        try:\n            instance = MyClass()\n        except TypeError as e:\n            print(e)\n        ```\n\n    Example: Class wrongly providing an `__init__` constructor\n        ```python\n        try:\n            @disable_init\n            class MyClass:\n                def __init__(self) -&gt; None:\n                    pass\n        except TypeError as e:\n            assert isinstance(e, TypeError)\n            print(e)\n        ```\n\n    Example: Using a custom error message when the default constructor is called\n        ```python\n        from typing import Self\n\n        class NoInitError(TypeError):\n            def __init__(self) -&gt; None:\n                super().__init__(\"Please create instances of MyClass using MyClass.new()\")\n\n        @disable_init(error=NoInitError())\n        class MyClass:\n            @classmethod\n            def new(cls) -&gt; Self:\n                return cls.__new__(cls)\n\n        try:\n            instance = MyClass()\n        except NoInitError as e:\n            assert str(e) == \"Please create instances of MyClass using MyClass.new()\"\n            print(e)\n        ```\n\n    Args:\n        cls: The class to be decorated.\n        error: The error to raise if __init__ is called, if `None` a default\n            [TypeError][] will be raised.\n\n    Returns:\n        A decorator that disables the `__init__` constructor of `cls`.\n    \"\"\"\n\n    def decorator(inner_cls: TypeT) -&gt; TypeT:\n        return cast(\n            TypeT,\n            _NoInitConstructibleMeta(\n                inner_cls.__name__,\n                inner_cls.__bases__,\n                dict(inner_cls.__dict__),\n                no_init_constructible_error=error,\n            ),\n        )\n\n    if cls is None:\n        return decorator\n    return decorator(cls)\n</code></pre>"}]}